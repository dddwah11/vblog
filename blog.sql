/*
 Navicat Premium Data Transfer

 Source Server         : 华为云
 Source Server Type    : MySQL
 Source Server Version : 80022
 Source Host           : 114.116.28.238:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80022
 File Encoding         : 65001

 Date: 21/10/2022 20:03:33
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for sys_category
-- ----------------------------
DROP TABLE IF EXISTS `sys_category`;
CREATE TABLE `sys_category`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `status` int(0) NULL DEFAULT NULL COMMENT '状态',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 127 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_category
-- ----------------------------
INSERT INTO `sys_category` VALUES (1, 'java', 0);
INSERT INTO `sys_category` VALUES (2, 'js', 0);
INSERT INTO `sys_category` VALUES (118, '其他', 0);
INSERT INTO `sys_category` VALUES (119, 'vue', 0);
INSERT INTO `sys_category` VALUES (120, 'linux', 0);
INSERT INTO `sys_category` VALUES (121, 'Hadoop', 0);
INSERT INTO `sys_category` VALUES (122, '操作系统', 0);
INSERT INTO `sys_category` VALUES (123, 'spring', 0);
INSERT INTO `sys_category` VALUES (124, 'mybatis', 0);
INSERT INTO `sys_category` VALUES (125, 'springboot', 0);
INSERT INTO `sys_category` VALUES (126, 'springMVC', 0);

-- ----------------------------
-- Table structure for sys_chat
-- ----------------------------
DROP TABLE IF EXISTS `sys_chat`;
CREATE TABLE `sys_chat`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 83 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_chat
-- ----------------------------
INSERT INTO `sys_chat` VALUES (36, '哈哈哈可以发表情');
INSERT INTO `sys_chat` VALUES (68, '嗡嗡嗡');
INSERT INTO `sys_chat` VALUES (70, '😀');
INSERT INTO `sys_chat` VALUES (71, '龙🐉');
INSERT INTO `sys_chat` VALUES (73, '666666666666');
INSERT INTO `sys_chat` VALUES (74, '哈哈哈哈谢谢你的光临');
INSERT INTO `sys_chat` VALUES (75, '谢谢你的光临');
INSERT INTO `sys_chat` VALUES (76, '我🎈🎆🎇🧨✨🎉🎊🎃🎋🎄🎍🎎🎏🎐🎑🧧');
INSERT INTO `sys_chat` VALUES (77, '🎇🎇🎇🎇🎇🎇🎇🎇✨✨🎉');
INSERT INTO `sys_chat` VALUES (78, '🍔🌭🥓🥓🌯🥠🍠🥩🍗🍖🍘🦪🍣🍣🍜🍚🥟🥟🥓🍿🍿🥚🥨');
INSERT INTO `sys_chat` VALUES (80, '谢谢你的光临！！！');

-- ----------------------------
-- Table structure for sys_dict
-- ----------------------------
DROP TABLE IF EXISTS `sys_dict`;
CREATE TABLE `sys_dict`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '名称',
  `value` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '图标',
  `type` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '类型',
  PRIMARY KEY (`id`, `name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 25 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_dict
-- ----------------------------
INSERT INTO `sys_dict` VALUES (1, 'main', 'el-icon-s-home', 'icon');
INSERT INTO `sys_dict` VALUES (2, 'menu', 'el-icon-menu', 'icon');
INSERT INTO `sys_dict` VALUES (3, 'role', 'el-icon-user-solid\r\nel-icon-user-solid\r\n', 'icon');
INSERT INTO `sys_dict` VALUES (4, 'user', 'el-icon-user', 'icon');
INSERT INTO `sys_dict` VALUES (5, 'start-on', 'el-icon-star-on', 'icon');
INSERT INTO `sys_dict` VALUES (6, 'start-off', 'el-icon-star-off', 'icon');
INSERT INTO `sys_dict` VALUES (7, 'setting', 'el-icon-s-tools', 'icon');
INSERT INTO `sys_dict` VALUES (8, 'ice-cream', 'el-icon-ice-cream-round', 'icon');
INSERT INTO `sys_dict` VALUES (9, 'data', 'el-icon-s-data\r\n', 'icon');
INSERT INTO `sys_dict` VALUES (10, 'shop', 'el-icon-s-shop', 'icon');
INSERT INTO `sys_dict` VALUES (11, 'platform', 'el-icon-s-platform', 'icon');
INSERT INTO `sys_dict` VALUES (12, 'help', 'el-icon-s-help', 'icon');
INSERT INTO `sys_dict` VALUES (13, 'upload', 'el-icon-upload', 'icon');
INSERT INTO `sys_dict` VALUES (14, 'promotion', 'el-icon-s-promotion', 'icon');
INSERT INTO `sys_dict` VALUES (15, 'opportunity', 'el-icon-s-opportunity\r\n', 'icon');
INSERT INTO `sys_dict` VALUES (16, 'basketball', 'el-icon-basketball', 'icon');
INSERT INTO `sys_dict` VALUES (17, 'crop', 'el-icon-crop', 'icon');
INSERT INTO `sys_dict` VALUES (18, 'chat', 'el-icon-chat-line-round', 'icon');
INSERT INTO `sys_dict` VALUES (19, 'original', 'el-icon-c-scale-to-original', 'icon');
INSERT INTO `sys_dict` VALUES (20, 'analysis', 'el-icon-data-analysis\r\nel-icon-data-analysis\r\nel-icon-data-analysis\r\nel-icon-data-analysis\r\nel-icon-data-analysis', 'icon');
INSERT INTO `sys_dict` VALUES (21, 'building', 'el-icon-office-building', 'icon');
INSERT INTO `sys_dict` VALUES (22, 'school', 'el-icon-school', 'icon');
INSERT INTO `sys_dict` VALUES (23, 'trophy', 'el-icon-trophy', 'icon');
INSERT INTO `sys_dict` VALUES (24, 'outline', 'el-icon-picture-outline', 'icon');

-- ----------------------------
-- Table structure for sys_file
-- ----------------------------
DROP TABLE IF EXISTS `sys_file`;
CREATE TABLE `sys_file`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文件名',
  `type` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文件类型',
  `size` bigint(0) NULL DEFAULT NULL COMMENT '文件大小',
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文件地址',
  `uuid` varbinary(255) NULL DEFAULT NULL,
  `is_photo` int(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 132 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for sys_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_menu`;
CREATE TABLE `sys_menu`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '名称',
  `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '路径',
  `icon` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '图标',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '描述',
  `pid` int(0) NULL DEFAULT NULL COMMENT '父级id',
  `page_path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '页面路径',
  `sort_num` int(0) NULL DEFAULT NULL COMMENT '顺序',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 74 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_menu
-- ----------------------------
INSERT INTO `sys_menu` VALUES (24, '系统管理', NULL, 'el-icon-s-tools', NULL, NULL, '', 3);
INSERT INTO `sys_menu` VALUES (25, '用户管理', '/user', 'el-icon-user', NULL, 24, 'UserView', NULL);
INSERT INTO `sys_menu` VALUES (26, '角色管理', '/role', 'el-icon-user-solid\r\nel-icon-user-solid\r\n', NULL, 24, 'RoleView', NULL);
INSERT INTO `sys_menu` VALUES (27, '菜单管理', '/menu', 'el-icon-menu', NULL, 24, 'MenuView', NULL);
INSERT INTO `sys_menu` VALUES (28, '主页', '/contain', 'el-icon-s-home', 'we', NULL, 'ContainMainView', 1);
INSERT INTO `sys_menu` VALUES (61, '数据监控', '/druid', 'el-icon-s-data\r\n', NULL, 24, 'DruidView', NULL);
INSERT INTO `sys_menu` VALUES (62, '博客管理', '', 'el-icon-ice-cream-round', NULL, NULL, 'BlogView', 4);
INSERT INTO `sys_menu` VALUES (63, '文章管理', '/article', 'el-icon-s-shop', NULL, 62, 'Article', NULL);
INSERT INTO `sys_menu` VALUES (64, '标签管理', '/tag', 'el-icon-s-platform', NULL, 62, 'Tag', NULL);
INSERT INTO `sys_menu` VALUES (65, '友链管理', '/link', 'el-icon-star-off', NULL, 62, 'Link', NULL);
INSERT INTO `sys_menu` VALUES (66, '发布文章', '/articleedit', 'el-icon-s-promotion', NULL, NULL, 'ArticleEdit', 2);
INSERT INTO `sys_menu` VALUES (67, '文件管理', '/file', 'el-icon-upload', NULL, 24, 'File', NULL);
INSERT INTO `sys_menu` VALUES (68, '评论管理', '/comment', 'el-icon-s-opportunity\r\n', NULL, 62, 'Comment', NULL);
INSERT INTO `sys_menu` VALUES (69, '类别管理', '/tagsview', 'el-icon-s-help', NULL, 62, 'TagsView', NULL);
INSERT INTO `sys_menu` VALUES (70, '留言板', '/chatview', 'el-icon-chat-line-round', NULL, NULL, 'ChatView', 5);
INSERT INTO `sys_menu` VALUES (71, '照片墙', '', 'el-icon-basketball', NULL, NULL, '', 6);
INSERT INTO `sys_menu` VALUES (72, '游玩列表', '/photoview', 'el-icon-ice-cream-round', NULL, 71, 'Photo', NULL);
INSERT INTO `sys_menu` VALUES (73, '图片', '/phtofile', 'el-icon-picture-outline', NULL, 71, 'PhotoFile', NULL);

-- ----------------------------
-- Table structure for sys_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT '角色id',
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '名称',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '描述',
  `user_key` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '唯一标识',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_role
-- ----------------------------
INSERT INTO `sys_role` VALUES (5, '管理员 ', '管理员', 'admin');
INSERT INTO `sys_role` VALUES (7, '普通用户', '普通用户', 'user');

-- ----------------------------
-- Table structure for sys_role_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_role_menu`;
CREATE TABLE `sys_role_menu`  (
  `role_id` int(0) NOT NULL COMMENT '角色id',
  `menu_id` int(0) NOT NULL COMMENT '菜单id',
  `id` int(0) NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`, `menu_id`, `role_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 224 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '角色菜单关系表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_role_menu
-- ----------------------------
INSERT INTO `sys_role_menu` VALUES (7, 99, 6);
INSERT INTO `sys_role_menu` VALUES (12, 27, 7);
INSERT INTO `sys_role_menu` VALUES (5, 28, 206);
INSERT INTO `sys_role_menu` VALUES (5, 66, 207);
INSERT INTO `sys_role_menu` VALUES (5, 24, 208);
INSERT INTO `sys_role_menu` VALUES (5, 25, 209);
INSERT INTO `sys_role_menu` VALUES (5, 26, 210);
INSERT INTO `sys_role_menu` VALUES (5, 27, 211);
INSERT INTO `sys_role_menu` VALUES (5, 61, 212);
INSERT INTO `sys_role_menu` VALUES (5, 67, 213);
INSERT INTO `sys_role_menu` VALUES (5, 62, 214);
INSERT INTO `sys_role_menu` VALUES (5, 63, 215);
INSERT INTO `sys_role_menu` VALUES (5, 64, 216);
INSERT INTO `sys_role_menu` VALUES (5, 65, 217);
INSERT INTO `sys_role_menu` VALUES (5, 68, 218);
INSERT INTO `sys_role_menu` VALUES (5, 69, 219);
INSERT INTO `sys_role_menu` VALUES (5, 70, 220);
INSERT INTO `sys_role_menu` VALUES (5, 71, 221);
INSERT INTO `sys_role_menu` VALUES (5, 72, 222);
INSERT INTO `sys_role_menu` VALUES (5, 73, 223);

-- ----------------------------
-- Table structure for sys_tag
-- ----------------------------
DROP TABLE IF EXISTS `sys_tag`;
CREATE TABLE `sys_tag`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '类别名',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_tag
-- ----------------------------
INSERT INTO `sys_tag` VALUES (1, '生活');
INSERT INTO `sys_tag` VALUES (2, '体育');
INSERT INTO `sys_tag` VALUES (4, '其他');
INSERT INTO `sys_tag` VALUES (7, '学习');
INSERT INTO `sys_tag` VALUES (8, '收集的诗');
INSERT INTO `sys_tag` VALUES (9, '网站bug');

-- ----------------------------
-- Table structure for t_blog
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `tittle` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '标题',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '描述',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '内容',
  `status` int(0) NULL DEFAULT NULL COMMENT '状态',
  `created_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `modified_time` datetime(0) NULL DEFAULT NULL COMMENT '修改时间',
  `weight` int(0) NULL DEFAULT NULL,
  `category_id` int(0) NULL DEFAULT NULL,
  `view_counts` int(0) NULL DEFAULT NULL,
  `thumbnail` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '略缩图',
  `tag_id` int(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 242 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES (202, '测试4', NULL, '', 0, '2022-09-05 13:45:15', '2022-10-21 20:01:00', 1, 1, 104, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/03/383c00b3b1ac4f309a503dcb9438d8a4.jpg', 1);
INSERT INTO `t_blog` VALUES (207, 'Mybatis', 'mybatis初学4月份笔记', '## Mybatis\n## 1、什么是Mybatis\n​	MyBatis本是apache的一个[开源项目](https://baike.baidu.com/item/开源项目/3406069)iBatis，2010年这个[项目](https://baike.baidu.com/item/项目/477803)由apache software foundation迁移到了[google code](https://baike.baidu.com/item/google code/2346604)，并且改名为MyBatis。2013年11月迁移到[Github](https://baike.baidu.com/item/Github/10145341)。\n\n​	iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的[持久层](https://baike.baidu.com/item/持久层/3584971)框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs）。\n\n​	当前，最新版本是MyBatis 3.5.9，其发布时间是2021年12月26日。\n\n## 2、持久化\n\n​	持久化是将程序数据在[持久](https://baike.baidu.com/item/持久/5702771)状态和[瞬时](https://baike.baidu.com/item/瞬时/3471916)状态间转换的机制。通俗的讲，就是瞬时数据（比如内存中的数据，是不能永久保存的）持久化为持久数据（比如持久化至数据库中，能够长久保存）。\n\n\n\n## 3、持久层\n\n​	可以理解成数据 保存在 数据库或者 硬盘一类可以保存很长时间的设备里面，不像放在内存中那样断电就消失了，也就是把数据存在持久化设备上，mybatis就是持久层。\n\n内存：断点即失\n\n\n\n## 4、Maven项目下创建第一个mybatis程序\n\n### 	4.1 导入依赖：mysql驱动、mybatis、lombok。\n\n### 注意：maven资源导出问题：最好，父类，子类都添加\n\n```xml\n<build>\n    <resources>\n        <resource>\n            <directory>src/main/resources</directory>\n            <includes>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>true</filtering>\n        </resource>\n        <resource>\n            <directory>src/main/java</directory>\n            <includes>\n                <include>**/*.properties</include>\n                <include>**/*.xml</include>\n            </includes>\n            <filtering>true</filtering>\n        </resource>\n    </resources>\n</build>\n```\n\n\n\n搭好项目结构：\n\n\n\n\n\n### 	4.3、去mybatis中文文档 粘贴需要用到的核心配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?userSSL=true&amp;userUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"123456\"/>\n            </dataSource>\n        </environment>\n    </environments>\n<!--    注册Mapper-->\n    <mappers>\n        <mapper resource=\"com/xiaoliu/Mapper/UserMapper.xml\"/>\n    </mappers>\n</configuration>\n```\n\n**注意：注册mapper**\n\n\n\n### 	4.4、编写实体类User\n\n```java\npackage com.xiaoliu.pojo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n/**\n * @author: 61分\n * @date: 2022/4/11 17:35\n * @description:\n */\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User {\n    private int id;\n    private String name;\n    private String password;\n\n}\n```\n\n\n\n### 	4.5、编写Mapper接口及实现的配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<!--namespace=绑定对应的Mapper接口-->\n<mapper namespace=\"com.xiaoliu.Mapper.UserMapper\">\n<!--    id对应的是方法名称-->\n    <select id=\"getUserList\" resultType=\"com.xiaoliu.pojo.User\">\n        select * from mybatis.user\n    </select>\n</mapper>\n```\n\n配置文件\n\nUserMappe接口\n\n```java\npackage com.xiaoliu.Mapper;\n\nimport com.xiaoliu.pojo.User;\n\nimport java.util.List;\n\n/**\n * @author: 61分\n * @date: 2022/4/11 17:41\n * @description:\n */\npublic interface UserMapper {\n    List<User> getUserList();\n\n}\n```\n\n​	\n\n### 	4.6、编写MybatisUtil类\n\n获取SQLSession\n\n执行SQLSession\n\n```java\npackage com.xiaoliu.utils;\n\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * @author: 61分\n * @date: 2022/4/11 15:55\n * @description:获取SQLSessionFactory\n */\npublic class MybatisUtils {\n    private static SqlSessionFactory sqlSessionFactory;\n    static {\n\n        try {\n//            获取SQLSessionFactory-》SQLSession\n            String resource = \"mybatis-config.xml\";\n            InputStream  inputStream = Resources.getResourceAsStream(resource);\n            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    //        既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。\n    //        SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。\n//        你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。\n    public static SqlSession getSqlSession(){\n        return sqlSessionFactory.openSession();\n\n    }\n}\n```\n\n\n\n### 4.7、编写Test类进行测试\n\n```java\npackage com.xiaoliu.Mapper;\n\nimport com.xiaoliu.pojo.User;\nimport com.xiaoliu.utils.MybatisUtils;\nimport org.apache.ibatis.session.SqlSession;\nimport org.junit.Test;\n\nimport java.util.List;\n\n/**\n * @author: 61分\n * @date: 2022/4/11 18:00\n * @description:\n */\npublic class UserMapperTest {\n    @Test\n    public void test(){\n//        第一步：获得sqlSession对象\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n        System.out.println(\"getsqlSession\");\n\n//        第二步，方式一：getMapper\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        List<User> userList = mapper.getUserList();\n        System.out.println(\"getMapper\");\n        for (User user : userList) {\n            System.out.println(user);\n        }\n//        关闭sqlSession\n        System.out.println(\"close\");\n\n        sqlSession.close();\n\n    }\n}\n```\n**测试成功：**\n\n## 5、学习总结\n\n​	**注意注册Mapper，及maven资源导出的问题**', 0, '2022-09-05 23:28:34', '2022-10-21 20:01:00', 0, 124, 4, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/03/6ca427a8caf64115b68b3983d19afae4.jpg', 7);
INSERT INTO `t_blog` VALUES (208, 'Mybatis02', '映射器', '## 映射器\n\n* 接口必须和Mapper配置文件同名\n* 接口必须和Mapper配置文件在同一个包下\n\n\n\n\n\n## 生命周期及其作用域\n\n* 生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。\n\n\n\n## 属性名和字段名的不一致\n\n* 利用resultMap（结果集映射）\n\n\n\n**UserMapper.xml：**\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.xiaoliu.Dao.UserMapper\">\n<!--    结果集映射-->\n    <!--    column为数据库中的字段名，property为实体类中的属性-->\n\n    <resultMap id=\"UserMap\" type=\"com.xiaoliu.pojo.User\">\n<!--        <result property=\"id\" column=\"id\"/>-->\n<!--        <result property=\"name\" column=\"name\"/>-->\n        <result property=\"pwd\" column=\"password\"/>\n    </resultMap>\n\n    <select id=\"getUserById\" resultMap=\"UserMap\">\n        select id,name,password from mybatis.user where id  = #{id}\n    </select>\n\n</mapper>\n```\n\n\n\n测试类：\n\n```java\npublic class UserMapperTest {\n\n    @Test\n    public void getUserById(){\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\n//        获取接口\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n\n        User user = mapper.getUserById(2);\n        System.out.println(user);\n        sqlSession.close();\n    }\n\n}\n```\n\n\n\n结果：\n\nUser{id=2, name=\'大刘哥\', pwd=\'1234\'}\n\nProcess finished with exit code 0', 0, '2022-09-05 23:30:43', '2022-10-21 20:01:00', 0, 124, 0, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/05/e15e51412367433f8bcfd949142e6543.jpg', 7);
INSERT INTO `t_blog` VALUES (209, 'Mybatis-03', ' 设置（settings）', '# Mybatis-03\n\n\n\n## 设置（settings）\n\n这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 下表描述了设置中各项设置的含义、默认值等。\n\n| 设置名                           | 描述                                                         | 有效值                                                       | 默认值                                                |\n| :------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :---------------------------------------------------- |\n| cacheEnabled                     | 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。     | true \\| false                                                | true                                                  |\n| lazyLoadingEnabled               | 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 `fetchType` 属性来覆盖该项的开关状态。 | true \\| false                                                | false                                                 |\n| aggressiveLazyLoading            | 开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载（参考 `lazyLoadTriggerMethods`)。 | true \\| false                                                | false （在 3.4.1 及之前的版本中默认为 true）          |\n| multipleResultSetsEnabled        | 是否允许单个语句返回多结果集（需要数据库驱动支持）。         | true \\| false                                                | true                                                  |\n| useColumnLabel                   | 使用列标签代替列名。实际表现依赖于数据库驱动，具体可参考数据库驱动的相关文档，或通过对比测试来观察。 | true \\| false                                                | true                                                  |\n| useGeneratedKeys                 | 允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。 | true \\| false                                                | False                                                 |\n| autoMappingBehavior              | 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。 | NONE, PARTIAL, FULL                                          | PARTIAL                                               |\n| autoMappingUnknownColumnBehavior | 指定发现自动映射目标未知列（或未知属性类型）的行为。`NONE`: 不做任何反应`WARNING`: 输出警告日志（`\'org.apache.ibatis.session.AutoMappingUnknownColumnBehavior\'` 的日志等级必须设置为 `WARN`）`FAILING`: 映射失败 (抛出 `SqlSessionException`) | NONE, WARNING, FAILING                                       | NONE                                                  |\n| defaultExecutorType              | 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（PreparedStatement）； BATCH 执行器不仅重用语句还会执行批量更新。 | SIMPLE REUSE BATCH                                           | SIMPLE                                                |\n| defaultStatementTimeout          | 设置超时时间，它决定数据库驱动等待数据库响应的秒数。         | 任意正整数                                                   | 未设置 (null)                                         |\n| defaultFetchSize                 | 为驱动的结果集获取数量（fetchSize）设置一个建议值。此参数只可以在查询设置中被覆盖。 | 任意正整数                                                   | 未设置 (null)                                         |\n| defaultResultSetType             | 指定语句默认的滚动策略。（新增于 3.5.2）                     | FORWARD_ONLY \\| SCROLL_SENSITIVE \\| SCROLL_INSENSITIVE \\| DEFAULT（等同于未设置） | 未设置 (null)                                         |\n| safeRowBoundsEnabled             | 是否允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。 | true \\| false                                                | False                                                 |\n| safeResultHandlerEnabled         | 是否允许在嵌套语句中使用结果处理器（ResultHandler）。如果允许使用则设置为 false。 | true \\| false                                                | True                                                  |\n| mapUnderscoreToCamelCase         | 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 | true \\| false                                                | False                                                 |\n| localCacheScope                  | MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。 默认值为 SESSION，会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。 | SESSION \\| STATEMENT                                         | SESSION                                               |\n| jdbcTypeForNull                  | 当没有为参数指定特定的 JDBC 类型时，空值的默认 JDBC 类型。 某些数据库驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 | JdbcType 常量，常用值：NULL、VARCHAR 或 OTHER。              | OTHER                                                 |\n| lazyLoadTriggerMethods           | 指定对象的哪些方法触发一次延迟加载。                         | 用逗号分隔的方法列表。                                       | equals,clone,hashCode,toString                        |\n| defaultScriptingLanguage         | 指定动态 SQL 生成使用的默认脚本语言。                        | 一个类型别名或全限定类名。                                   | org.apache.ibatis.scripting.xmltags.XMLLanguageDriver |\n| defaultEnumTypeHandler           | 指定 Enum 使用的默认 `TypeHandler` 。（新增于 3.4.5）        | 一个类型别名或全限定类名。                                   | org.apache.ibatis.type.EnumTypeHandler                |\n| callSettersOnNulls               | 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这在依赖于 Map.keySet() 或 null 值进行初始化时比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。 | true \\| false                                                | false                                                 |\n| returnInstanceForEmptyRow        | 当返回行的所有列都是空时，MyBatis默认返回 `null`。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集（如集合或关联）。（新增于 3.4.2） | true \\| false                                                | false                                                 |\n| logPrefix                        | 指定 MyBatis 增加到日志名称的前缀。                          | 任何字符串                                                   | 未设置                                                |\n| logImpl                          | 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。        | SLF4J \\| LOG4J \\| LOG4J2 \\| JDK_LOGGING \\| COMMONS_LOGGING \\| STDOUT_LOGGING \\| NO_LOGGING | 未设置                                                |\n| proxyFactory                     | 指定 Mybatis 创建可延迟加载对象所用到的代理工具。            | CGLIB \\| JAVASSIST                                           | JAVASSIST （MyBatis 3.3 以上）                        |\n| vfsImpl                          | 指定 VFS 的实现                                              | 自定义 VFS 的实现的类全限定名，以逗号分隔。                  | 未设置                                                |\n| useActualParamName               | 允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的项目必须采用 Java 8 编译，并且加上 `-parameters` 选项。（新增于 3.4.1） | true \\| false                                                | true                                                  |\n| configurationFactory             | 指定一个提供 `Configuration` 实例的类。 这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。 这个类必须包含一个签名为`static Configuration getConfiguration()` 的方法。（新增于 3.2.3） | 一个类型别名或完全限定类名。                                 | 未设置                                                |\n\n一个配置完整的 settings 元素的示例如下：\n\n```\n<settings>\n  <setting name=\"cacheEnabled\" value=\"true\"/>\n  <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n  <setting name=\"multipleResultSetsEnabled\" value=\"true\"/>\n  <setting name=\"useColumnLabel\" value=\"true\"/>\n  <setting name=\"useGeneratedKeys\" value=\"false\"/>\n  <setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/>\n  <setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/>\n  <setting name=\"defaultExecutorType\" value=\"SIMPLE\"/>\n  <setting name=\"defaultStatementTimeout\" value=\"25\"/>\n  <setting name=\"defaultFetchSize\" value=\"100\"/>\n  <setting name=\"safeRowBoundsEnabled\" value=\"false\"/>\n  <setting name=\"mapUnderscoreToCamelCase\" value=\"false\"/>\n  <setting name=\"localCacheScope\" value=\"SESSION\"/>\n  <setting name=\"jdbcTypeForNull\" value=\"OTHER\"/>\n  <setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/>\n</settings>\n```\n\n\n\n```xml\n<settings>\n    <setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>\n</settings>\n```\n\n\n\n### STDOUT_LOGGING标准日志输出：\n\n\n\nLogging initialized using \'class org.apache.ibatis.logging.stdout.StdOutImpl\' adapter.\nPooledDataSource forcefully closed/removed all connections.\nPooledDataSource forcefully closed/removed all connections.\nPooledDataSource forcefully closed/removed all connections.\nPooledDataSource forcefully closed/removed all connections.\nOpening JDBC Connection\nCreated connection 775386112.\nSetting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2e377400]\n==>  Preparing: select id,name,password from mybatis.user where id = ?\n==> Parameters: 2(Integer)\n<==    Columns: id, name, password\n<==        Row: 2, 大刘哥, 1234\n<==      Total: 1\nUser{id=2, name=\'大刘哥\', pwd=\'1234\'}\nResetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2e377400]\nClosing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2e377400]\nReturned connection 775386112 to pool.\n\nProcess finished with exit code 0\n\n\n\n## Log4j\n\n* 控制日志信息输送的目的地是[控制台](https://baike.baidu.com/item/控制台/2438626)、文件、[GUI](https://baike.baidu.com/item/GUI)组件，甚至是套接口服务器、[NT](https://baike.baidu.com/item/NT/3443842)的事件记录器、[UNIX](https://baike.baidu.com/item/UNIX) [Syslog](https://baike.baidu.com/item/Syslog)[守护进程](https://baike.baidu.com/item/守护进程/966835)等；\n* 我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。\n* 最令人感兴趣的就是，这些可以通过一个[配置文件](https://baike.baidu.com/item/配置文件/286550)来灵活地进行配置，而不需要修改应用的代码。\n\n\n\n​	导入相关依赖\n\n\n\nlog4j.properties\n\n```properties\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\nlog4j.rootLogger=DEBUG,console,file\n\n#控制台输出的相关设置\nlog4j.appender.console = org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target = System.out\nlog4j.appender.console.Threshold=DEBUG\nlog4j.appender.console.layout = org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n\n\n#文件输出的相关设置\nlog4j.appender.file = org.apache.log4j.RollingFileAppender\nlog4j.appender.file.File=./log/xiaoliu.log\nlog4j.appender.file.MaxFileSize=10mb\nlog4j.appender.file.Threshold=DEBUG\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n\n\n#日志输出级别\nlog4j.logger.org.mybatis=DEBUG\nlog4j.logger.java.sql=DEBUG\nlog4j.logger.java.sql.Statement=DEBUG\nlog4j.logger.java.sql.ResultSet=DEBUG\nlog4j.logger.java.sql.PreparedStatement=DEBUG\n```\n\n配置文件的实现：\n\n```xml\n<settings>\n        <setting name=\"logImpl\" value=\"LOG4J\"/>\n    </settings>\n```\n\n\n\nD:\\Java\\jdk1.8.0_191\\bin\\java.exe -ea -Didea.test.cyclic.buffer.size=1048576 \"-javaagent:D:\\IntelliJ \n?org.apache.ibatis.transaction.jdbc.JdbcTransaction?-Opening JDBC Connection\n?org.apache.ibatis.datasource.pooled.PooledDataSource?-Created connection 1151844284.\n?org.apache.ibatis.transaction.jdbc.JdbcTransaction?-Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@44a7bfbc]\n?com.xiaoliu.Dao.UserMapper.getUserById?-==>  Preparing: select id,name,password from mybatis.user where id = ?\n?com.xiaoliu.Dao.UserMapper.getUserById?-==> Parameters: 2(Integer)\n?com.xiaoliu.Dao.UserMapper.getUserById?-<==      Total: 1\nUser{id=2, name=\'大刘哥\', pwd=\'1234\'}\n?org.apache.ibatis.transaction.jdbc.JdbcTransaction?-Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@44a7bfbc]\n?org.apache.ibatis.transaction.jdbc.JdbcTransaction?-Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@44a7bfbc]\n?org.apache.ibatis.datasource.pooled.PooledDataSource?-Returned connection 1151844284 to pool.\n\nProcess finished with exit code 0\n\n\n\n在使用时要记得到入包\n\n```java\nimport org.apache.log4j.Logger;\n```\n\n并在要使用的类下面使用当前的class\n\n```java\nstatic Logger logger = Logger.getLogger(UserMapperTest.class);\n```\n\n\n\n## 分页', 0, '2022-09-05 23:32:58', '2022-10-21 20:01:00', 0, 124, 1, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/03/653c01916a9341d19943de27fc4b5587.jpg', 7);
INSERT INTO `t_blog` VALUES (210, 'spirngboot初学', 'SpringBoot原理', '# SpringBoot原理\n\n## 1、自动装配原理	\n\n**pom.xml**\n\n* spring-boot-dependencies:核心依赖在父工程中\n* 我们在引入一些spring依赖的时候，不需要指定版本，因为有这些版本仓库\n\n\n\n**启动器**\n\n* ```xml\n  <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n  </dependency>\n  ```\n\n* 是springboot的启动场景\n  * 比如springbootwb 就帮我们自动导入web环境所需的所有依赖！\n* 将所有的功能场景变成一个个启动器\n\n\n\n**springboot主程序** \n\n```java\n@SpringBootApplication\npublic class HelloWorldApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloWorldApplication.class, args);\n    }\n\n}\n```\n\n\n\n**注解**\n\n```java\n@SpringBootConfiguration\n@SpringBootConfiguration\n```\n\n\n\n自动配置的核心文件\n\n`WEB-INF/spring.factories` \n\n所有的资源加载到配置类中\n\n```java\nProperties properties = PropertiesLoaderUtils.loadProperties(resource)\n```\n\n核心注解\n\n```java\n@ConditionalOnXXX	在满足所有条件才会生效 \n```\n\n\n\nspringboot自动配置都在启动的时候扫描并加载 `spirng.properties` 所有的自动配置类都在这个配置文件中，通过判断核心注解是否满足条件才能生效\n\n* springboot在启动的时候，通过类路径下的 `WEB-INF/spirng.properties` 获得指定的值\n* 将这些自动配置的类导入容器，自动配置就会生效\n* 即完成自动配置\n  * 整合javaEE 解决方案和自动配置的东西都在 `spring-boot-test-autoconfigure-2.3.7.RELEASE.jar` 中', 0, '2022-09-05 23:33:39', '2022-10-21 20:01:00', 0, 125, 1, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/03/319fcc4360ee4c039ad6ba6eefee6f7b.jpg', 7);
INSERT INTO `t_blog` VALUES (211, 'SpringBoot Web开发', 'jar:webpp!', '# jar:webpp!\n\n* 导入静态资源\n* 首页\n* jsp，模板引擎Thymeleaf\n* 装配扩展SpringMVC\n* 增删改查\n* 拦截器\n* 国际化\n\n\n\n在springboot，我们使用以下方式处理静态资源\n\n* webjars	`localhost:8080/webjars/`\n  * public，static，/**,resource 	`localhost:8080/`\n* 优先级 resource>static(默认)>public\n\n\n\n# 首页如何定制\n\nindex.html\n\n最好设置在static里\n\n\n\n```\n在templates目录下的页面，只通过controller来跳转\n需要模板引擎的支持\n```\n', 0, '2022-09-05 23:34:28', '2022-10-21 20:01:00', 0, 1, 1, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/03/6ca427a8caf64115b68b3983d19afae4.jpg', 7);
INSERT INTO `t_blog` VALUES (212, '自动装配原理', '一些配置', '# 主启动类运行\n\n* 初始化 判断是不是为一个web应用\n* 打开监听器全局处理上下文\n* 通过主类加载，通过类加载获取spring。factories\n* 装配环境参数\n\n\n\n# yaml\n\n* 可以给实体类赋值\n\n  \n\n* ```yaml\n  # k = v\n  # 注入到我们配置类中\n  # 普通的key-value\n  name : xiaoliu\n  \n  dog:\n    name: xiaogou\n    age: 3\n  # 对象\n  student:\n    name: xiaoliu\n    age: 3\n  \n  ##  行内写法\n  student1: {name: xialiu, age: 3}\n  \n  ##数组\n  pets:\n    - dog\n    - vat\n    -  cat\n  \n    pets1: [dog,we,zw]\n  \n  ##对象\n    person:\n    name: xiaoliu\n    age: 3\n    happy: flase\n    birth: 2022/10/2\n    map: {k2: v1,k1: v2}\n    list:\n      - code\n      - music\n      - book\n  ```\n\n\n\n```java\n@ConfigurationProperties(prefix = \"person\")\n```\n\n可以通过这个注解将配置文件中的值映射到组件 `@component` 上\n\n\n\n也可以通过 `@PropertySource(\"classpath:xiaoliu.properties\")` 注解映射到组件上\n\n```java\n//加载指定的配置文件\n@PropertySource(\"classpath:xiaoliu.properties\")\npublic class Person {\n//    SPEL表达式取值\n    @Value(\"${name}\")\n```\n\n\n\n# 松散绑定\n\n在yml中 写的为last-name 与lastName是一样的\n\n\n\n# jsr303校验\n\n**约束注解名称	约束注解说明**\n**@Null	验证对象是否为空**\n**@NotNull	验证对象是否为非空**\n**@AssertTrue	验证 Boolean 对象是否为 true**\n**@AssertFalse	验证 Boolean 对象是否为 false**\n**@Min	验证 Number 和 String 对象是否大等于指定的值**\n**@Max	验证 Number 和 String 对象是否小等于指定的值**\n**@DecimalMin	验证 Number 和 String 对象是否大等于指定的值，小数存在精度**\n**@DecimalMax	验证 Number 和 String 对象是否小等于指定的值，小数存在精度**\n**@Size	验证对象（Array,Collection,Map,String）长度是否在给定的范围之内**\n**@Digits	验证 Number 和 String 的构成是否合法**\n**@Past	验证 Date 和 Calendar 对象是否在当前时间之前**\n**@Future	验证 Date 和 Calendar 对象是否在当前时间之后**\n**@Pattern	验证 String 对象是否符合正则表达式的规则**\n\n\n\n# 自动配置原理\n\nxxxAutoConfiguration: 	默认值  xxxproperties 和配置文件绑定 我们就可以使用自定义的配置 \n\n每一个 xxxAutoConfiguration 都是容器中的一个组件，最后都加入到容器中让他们自动配置\n\n\n\n**这就是自动装配的原理!**\n**精髓:**\n**1)、SpringBoot启动会加载大量的自动配置类**\n**2)、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中;**\n**3)、我们再来看这个自动配置类中到底配置了哪些组件; (只要我们要用的组件存在在其中，我们**\n**就不需要再手动配置了)**\n**4)、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置**\n**文件中指定这些属性的值即可;**\n**xxxxAutoConfigurartion:自动配置类;给容器中添加组件**\n**xxxxProperties:封装配置文件中相关属性文件**\n\n', 0, '2022-09-05 23:35:35', '2022-10-21 20:01:00', 0, 125, 1, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/03/d9dae83913d7450d9bb0a70e6077c7e7.jpg', 7);
INSERT INTO `t_blog` VALUES (213, 'MVC配置原理及thymeleaf', '如果想要div一些定制化的功能，只要写一个组件，然后将它交给springboot，springboot就会自动帮我们转配', '# MVC配置原理\n如果想要div一些定制化的功能，只要写一个组件，然后将它交给springboot，springboot就会自动帮我们转配\n\n```java\npackage com.xiaoliu.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.View;\nimport org.springframework.web.servlet.ViewResolver;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\nimport java.util.Locale;\n\n/**\n * @author: 61分\n * @date: 2022/4/15 21:17\n * @description:\n */\n//扩展 springmvc  dispatcherservlet\n@Configuration\n\npublic class MyMvcConfig implements WebMvcConfigurer {\n\n\n    @Bean\n    public ViewResolver myViewResolver(){\n        return new myViewResolver();\n    }\n\n//    自定义一个视图解析器\n    public static class myViewResolver implements ViewResolver {\n        @Override\n        public View resolveViewName(String s, Locale locale) throws Exception {\n            return null;\n        }\n    }\n}\n```\n\n\n\n基本的视图跳转\n\n```java\npublic class MyMvcConfig implements WebMvcConfigurer {\n\n    //视图跳转\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController(\"/xiaoliu\").setViewName(\"index\");\n    }\n}\n```\n\n**这样的话，视图跳转的文件，只能在templates，**  **而且thymeleaf也会失效**\n\n如果要扩展的话，官方建议这样去做\n\nspringboot中，xxxConfiguraion 可以实现很多扩展\n\n\n\n# thymeleaf\n\n**thymeleaf常用命名空间**：\n\nxmlns:th=\"http://www.thymeleaf.org\"\nxmlns:sec=\"http://www.thymeleaf.org/extras/spring-security\"\nxmlns:shiro=\"http://www.pollix.at/thymeleaf/shiro\"\n\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\" \n				xmlns:sec=\"http://www.thymeleaf.org/extras/spring-security\"\n				xmlns:shiro=\"http://www.pollix.at/thymeleaf/shiro\">\n', 0, '2022-09-05 23:43:50', '2022-10-21 20:01:00', 0, 1, 3, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/05/9745901e813040c6ae2a33f9c531f83b.jpg', 7);
INSERT INTO `t_blog` VALUES (214, ' springbootWeb-02开发', '员工列表展示', '# 员工列表展示\n\n* 提前公共页面\n  * `th:replace=\"~{commons/commons::sidebar``\n  * ``<div th:replace=\"~{commons/commons::tobbar}\"></div>`\n  * 如果要传参，可以直接使用（）传参，接受判断\n* 列表循坏展示\n\n\n\n`<tbody>\n   <tr th:each=\"emp:${emps}\">\n      <td th:text=\"${emp.getId()}\"></td>\n      <td th:text=\"${emp.getLastName()}\"></td>\n      <td th:text=\"${emp.getEmail()}\"></td>\n      <td th:text=\"${emp.getGender()==0?\'女\':\'男\'}\"></td>\n      <td th:text=\"${emp.department.getDepartment()}\"></td>\n      <td th:text=\"${#dates.format(emp.getBirth(),\'yyyy-MM-dd HH:mm:ss\')}\"></td>\n      <td>\n         <button class=\"btn btn-sm btn-primary\">编辑</button>\n         <button class=\"btn btn-sm btn-danger\">删除</button>\n      </td>\n   </tr>\n</tbody>`\n\n\n\n# 添加员工\n\n\n\n按钮提交\n\n跳转到添加页面\n\n添加员工成功\n\n返回首页\n\n\n\n**a标签使用get方法**', 0, '2022-09-05 23:45:50', '2022-10-21 20:01:00', 0, 125, 0, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/05/8b95ef5b132b464192f4079f4ea21e82.jpg', 7);
INSERT INTO `t_blog` VALUES (215, 'springbootWeb开发', '首页配置：所有html页面使用thymeleaf接管', '# 1、首页配置：所有html页面使用thymeleaf接管：\n\n`url:@{}`\n\n首页：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n   <head>\n      <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\">\n      <meta name=\"description\" content=\"\">\n      <meta name=\"author\" content=\"\">\n      <title>Signin Template for Bootstrap</title>\n      <!-- Bootstrap core CSS -->\n      <link th:href=\"@{/css/bootstrap.min.css}\" rel=\"stylesheet\">\n      <!-- Custom styles for this template -->\n      <link th:href=\"@{/css/signin.css}\" rel=\"stylesheet\">\n   </head>\n\n   <body class=\"text-center\">\n      <form class=\"form-signin\" action=\"dashboard.html\">\n         <img class=\"mb-4\" th:src=\"@{/img/bootstrap-solid.svg}\" alt=\"\" width=\"72\" height=\"72\">\n         <h1 class=\"h3 mb-3 font-weight-normal\">Please sign in</h1>\n         <label class=\"sr-only\">Username</label>\n         <input type=\"text\" class=\"form-control\" placeholder=\"Username\" required=\"\" autofocus=\"\">\n         <label class=\"sr-only\">Password</label>\n         <input type=\"password\" class=\"form-control\" placeholder=\"Password\" required=\"\">\n         <div class=\"checkbox mb-3\">\n            <label>\n          <input type=\"checkbox\" value=\"remember-me\"> Remember me\n        </label>\n         </div>\n         <button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\">Sign in</button>\n         <p class=\"mt-5 mb-3 text-muted\">© 2017-2018</p>\n         <a class=\"btn btn-sm\">中文</a>\n         <a class=\"btn btn-sm\">English</a>\n      </form>\n\n   </body>\n\n</html>\n```\n\n\n\ncontroller：\n\n```java\npackage com.xiaoliu.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.ViewControllerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n/**\n * @author: 61分\n * @date: 2022/4/15 21:17\n * @description:\n */\n//扩展 springmvc  dispatcherservlet\n@Configuration\n\npublic class MyMvcConfig implements WebMvcConfigurer {\n\n    //视图跳转\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController(\"/\").setViewName(\"index\");\n        registry.addViewController(\"/index.html\").setViewName(\"index\");\n    }\n}\n```\n\n\n\n## 2、页面国际化\n\ni18n\n\n设置login.properties文件，\n\nlogin.tip\n\nlogin.password\n\nlogin.username\n\nlogin.remember\n\n怎么识别国际化\n\n通过SpirngBoot——MessageSourceAutofiguration类\n\n\n\n在配置application.properties\n\n`spring.messages.basename=i18n.login`\n\nthymeleaf国际化消息语法：`#{}`\n\n\n\n```html\nth:text=\"#{login.password}\"\n```\n\n实现语言切换\n\n```html\nth:href=\"@{/index.html(l=\'zh_CN\')}\">中文\n```\n\n```html\nth:href=\"@{/index.html(l=\'en_US\')}\">Englis\n```\n\n\n\ndiv自己的组件在config中的MyMvcConfig类中\n\n并将其配置到springboot容器中 `@Bean`\n\n```java\n//    向容器中注入组件，自定义的国际化组件\n    @Bean\n    public LocaleResolver localeResolver(){\n        return new MylocalResolver();\n    }\n```\n\n\n\n自定义的组件\n\n```java\npackage com.xiaoliu.config;\n\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.servlet.LocaleResolver;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.Locale;\n\n/**\n * @author: 61分\n * @date: 2022/4/16 15:22\n * @description:\n */\npublic class MylocalResolver implements LocaleResolver {\n    @Override\n    public Locale resolveLocale(HttpServletRequest httpServletRequest) {\n//      获取语言参数\n        String language = httpServletRequest.getParameter(\"l\");\n        Locale locale = Locale.getDefault(); //如果没有就使用默认的\n//        如果请求中携带了地区化的参数\n        if (!StringUtils.isEmpty(language)){\n//            分割 zh_CN\n            String[] split = language.split(\"_\");\n//           国家 地区\n             locale = new Locale(split[0], split[1]);\n        }\n        return locale;\n    }\n\n    @Override\n    public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) {\n\n    }\n}\n```\n\n\n\n# 修改返回的url\n\n在自定义的视图跳转MyMvcConfig中\n\n视图跳转到dashboard的时候 名字为：main.html\n\n```java\nregistry.addViewController(\"/main.html\").setViewName(\"dashboard\");\n```\n\n\n\n在controller返回重定向的页面为/main.html\n\n```java\nif (!StringUtils.isEmpty(username) && \"123\".equals(password)) {\n    return \"redirect:/main.html\";\n```\n\n\n\n# 拦截器\n\n在config中 编写LoginHandlerInterceptor拦截器\n\n```java\npackage com.xiaoliu.config;\n\nimport org.springframework.web.servlet.HandlerInterceptor;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * @author: 61分\n * @date: 2022/4/16 16:14\n * @description:\n */\npublic class LoginHandlerInterceptor implements HandlerInterceptor {\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n//        登录之后应该有用户的session\n        Object loginUser = request.getSession().getAttribute(\"loginUser\");\n\n        if (loginUser==null){\n            request.setAttribute(\"msg\",\"没有权限，请先登录！\");\n            request.getRequestDispatcher(\"/index.html\").forward(request,response);\n            return false;\n        }else return true;\n    }\n\n\n}\n```\n\n\n\n在mvc类中重写拦截器\n\n```java\n@Override\npublic void addInterceptors(InterceptorRegistry registry) {\n    registry.addInterceptor(new LoginHandlerInterceptor())\n            .addPathPatterns(\"/**\")//拦截的页面\n            .excludePathPatterns(\"/\",\"/index.html\",\"/user/login\",\"/css/**\",\"/js/**\",\"/img/**\");//不能被拦截的页面\n}\n```\n\n', 0, '2022-09-05 23:47:10', '2022-10-21 20:01:00', 0, 125, 1, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/05/527375049f1249f99ddedc66b9a84836.jpg', 7);
INSERT INTO `t_blog` VALUES (216, '通过java自建数据表 ', '通过HashMap', '# 建立一个员工部门表：\n\n# pojo:\n\n**Employee:**\n\n```java\npackage com.xiaoliu.pojo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.util.Date;\n\n/**\n * @author: 61分\n * @date: 2022/4/15 23:12\n * @description:\n */\n@Data\n@NoArgsConstructor\npublic class Employee {\n    private Integer id;\n    private String lastName;\n    private String email;\n    private Integer gender;\n\n    private Department department;\n    private Date birth;\n\n    public Employee(Integer id, String lastName, String email, Integer gender, Department department) {\n        this.id = id;\n        this.lastName = lastName;\n        this.email = email;\n        this.gender = gender;\n        this.department = department;\n        this.birth = new Date();\n    }\n}\n```\n\n**Department:**\n\n\n\n```java\npackage com.xiaoliu.pojo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n/**\n * @author: 61分\n * @date: 2022/4/15 22:17\n * @description:\n */\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Department {\n    private Integer id;\n    private String department;\n}\n```\n\n\n\n## Dao层：\n\n\n\n**EmployeeDao：**\n\n```java\npackage com.xiaoliu.dao;\n\nimport com.xiaoliu.pojo.Department;\nimport com.xiaoliu.pojo.Employee;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author: 61分\n * @date: 2022/4/15 23:44\n * @description:\n */\npublic class EmployeeDao {\n    private static Map<Integer, Employee> employees;\n\n    @Autowired\n    private DepartmentDao departmentDao;\n\n    static {\n        employees = new HashMap<Integer, Employee>();//创建一个部门表\n        employees.put(1001, new Employee(1001,\"AA\",\"A13151@ew.com\",0,new Department(101,\"教学部\")));\n        employees.put(1002, new Employee(1002,\"BB\",\"B13151@ew.com\",1,new Department(102,\"后勤部\")));\n        employees.put(1003, new Employee(1003,\"CC\",\"C13151@ew.com\",0,new Department(103,\"保卫部\")));\n        employees.put(1004, new Employee(1004,\"DD\",\"D13151@ew.com\",1,new Department(104,\"科研部\")));\n        employees.put(1005, new Employee(1005,\"EE\",\"E13151@ew.com\",0,new Department(105,\"学生部\")));\n\n    }\n\n//    主键自增ID\n    private static Integer initId = 1006;\n//    增加一个员工\n    public void save(Employee employee){\n        if (employee.getId()==0){\n            employee.setId(initId++);\n        }\n\n        employee.setDepartment(departmentDao.getDepartment(employee.getDepartment().getId()));\n\n        employees.put(employee.getId(),employee);\n    }\n\n//    查询全部员工\n    public Collection<Employee> getAll(){\n        return employees.values();\n    }\n\n//    通过id查询员工\n    public Employee getById(Integer id){\n        return employees.get(id);\n    }\n\n//    删除员工通过id\n    public Employee removeById(Integer id){\n        return employees.remove(id);\n    }\n}\n```\n\n\n\n**DepartmentDao：**\n\n\n\n```java\npackage com.xiaoliu.dao;\n\nimport com.xiaoliu.pojo.Department;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author: 61分\n * @date: 2022/4/15 23:18\n * @description:\n */\npublic class DepartmentDao {\n//    模拟数据库中的数据\n        private  static Map<Integer, Department> departments = null;\n    static {\n        departments = new HashMap<Integer, Department>();//创建一个部门数据表\n        departments.put(101,new Department(101,\"教学部\"));\n        departments.put(102,new Department(102,\"后勤部\"));\n        departments.put(103,new Department(103,\"保卫部\"));\n        departments.put(104,new Department(104,\"科研部\"));\n        departments.put(105,new Department(105,\"学生部\"));\n\n    }\n//    获得部门信息\n    public Collection<Department> getDepartments(){\n        return departments.values();\n    }\n\n//    通过id得到部门\n    public Department getDepartment(Integer id){\n        return departments.get(id);\n    }\n}\n```\n', 0, '2022-09-05 23:52:08', '2022-10-21 20:01:00', 0, 1, 0, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/05/1510f1cf53e247d3987af0420303677d.jpg', 7);
INSERT INTO `t_blog` VALUES (217, '整合Druid', 'java整合druid', '# 1、导入相关依赖\n\n```xml\n<dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.12</version>\n</dependency>\n\n\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid</artifactId>\n    <version>1.2.9</version>\n</dependency>\n```\n\n\n\n# 2、配置文件\n\n\n\n```yml\ntype: com.alibaba.druid.pool.DruidDataSource\n\n  #SpringBoot默认是不注入这些的，需要自己绑定\n  #druid数据源专有配置\n  initialSize: 5\n  minIdle: 5\n  maxActive: 20\n  maxWait: 60000\n  timeBetweenEvictionRunsMillis: 60000\n  minEvictableIdleTimeMillis: 300000\n  validationQuery: SELECT 1 FROM DUAL\n  testWhileIdle: true\n  testOnBorrow: false\n  testOnReturn: false\n  poolPreparedStatements: true\n\n  #配置监控统计拦截的filters，stat：监控统计、log4j：日志记录、wall：防御sql注入\n  #如果允许报错，java.lang.ClassNotFoundException: org.apache.Log4j.Properity\n  #则导入log4j 依赖就行\n  filters: stat,wall,log4j\n  maxPoolPreparedStatementPerConnectionSize: 20\n  useGlobalDataSourceStat: true\n  connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\n```\n\n**配置进去没用，也能进去，先放着**\n\n\n\n\n\n# 3、绑定配置文件\n\n```java\npackage com.xiaoliu.config;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport javax.sql.DataSource;\n\n/**\n * @author: 61分\n * @date: 2022/4/18 14:33\n * @description:\n */\n@Configuration\npublic class DruidConfig {\n\n    @ConfigurationProperties(prefix = \"spring.datasource\")\n    @Bean\n    public DataSource DruidDataSource(){\n        return new DruidDataSource();\n    }\n}\n```\n\n\n\n# 4、DruidConfig\n\n```java\npackage com.xiaoliu.config;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport com.alibaba.druid.support.http.StatViewServlet;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.web.servlet.ServletRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport javax.sql.DataSource;\nimport java.util.HashMap;\n\n/**\n * @author: 61分\n * @date: 2022/4/18 14:33\n * @description:\n */\n@Configuration\npublic class DruidConfig {\n\n    @ConfigurationProperties(prefix = \"spring.datasource\")\n    @Bean\n    public DataSource DruidDataSource(){\n        return new DruidDataSource();\n    }\n\n//    后台监控:web.xml\n//    springboot集成了servlet，没有web.xml 可以使用ServletRegistrationBean，注册\n    @Bean\n    public ServletRegistrationBean statViewServlet(){\n        ServletRegistrationBean<StatViewServlet> bean = new ServletRegistrationBean<>(new StatViewServlet(), \"/druid/*\");\n//        后台有人登陆，账号密码配置\n        HashMap<String, String> initParameter = new HashMap<>();\n//        设置参数\n        initParameter.put(\"loginUsername\", \"admin\");//默认的数值\n        initParameter.put(\"loginPassword\",\"123456\");//默认的数值\n\n//        允许谁访问\n        initParameter.put(\"allow\",\"\");//后面参数不写，任何人都能访问\n//        禁止谁访问         initParameter.put(\"xxx\",\"ip地址\");\n\n\n        bean.setInitParameters(initParameter);//设置初始化参数\n        return bean;\n    }\n}\n```\n\n**过滤器**\n\n```java\n//    filter\n    @Bean\n    public FilterRegistrationBean filterStart(){\n        FilterRegistrationBean<Filter> bean = new FilterRegistrationBean<>();\n        bean.setFilter(new WebStatFilter());\n//        设置过滤请求\n        HashMap<String, String> initParameters = new HashMap<>();\n//        设置不统计的东西\n        initParameters.put(\"exclusions\",\"*.js,*.css,/druid/*\");\n        bean.setInitParameters(initParameters);\n        return bean;\n\n    }\n```\n', 0, '2022-09-05 23:53:04', '2022-10-21 20:01:00', 0, 1, 0, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/05/e5f99aa95ea84870adc3c93854d6bc05.png', 7);
INSERT INTO `t_blog` VALUES (218, '整合Mybatis', '整合mybatis', '准备工作：搭建环境并测试（导入包，配置文件，myabtis配置，编写sql）\n# 1、编写实体类\n\n```java\npackage com.xiaoliu.pojo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n/**\n * @author: 61分\n * @date: 2022/4/18 15:29\n * @description:\n */\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User {\n    private Integer id;\n    private String name;\n    private String password;\n}\n```\n\n\n\n# 2、编写接口\n\n```java\npackage com.xiaoliu.mapper;\n\n/**\n * @author: 61分\n * @date: 2022/4/18 15:32\n * @description:\n */\n\n@org.apache.ibatis.annotations.Mapper\npublic interface Mapper {\n}\n```\n\n\n\n```java\n@Repository //Dao层 用该注解\n```\n\n\n\n再到resource目录下配置xml文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n  PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.xiaoliu.mapper\">\n  <select id=\"selectBlog\" resultType=\"User\">\n    select * from Blog where id = #{id}\n  </select>\n</mapper>\n```\n\n\n\n在springboot中配置文件别名及mapper.xml文件\n\n```yaml\nmybatis.type-aliases-package=com.xiaoliu.pojo\nmybatis.mapper-locations=classpath:/mybatis/mapper/*.xml\n```\n\n\n\n增删改查\n\n```xml\n<select id=\"queryUserListById\" resultType=\"User\">\n    select * from mybatis.user where id = #{id}\n</select>\n\n<select id=\"queryUserList\" resultType=\"User\">\n    select * from mybatis.user\n</select>\n\n<insert id=\"addUser\" parameterType=\"User\">\n    insert into mybatis.user (id, name, password) values (#{id},#{name},#{password});\n</insert>\n\n<update id=\"updateUser\" parameterType=\"User\">\n    update mybatis.user\n    set name = #{name},\n        password = #{password}\n    where id = #{id};\n```\n\n\n\n配置文件：\n\n```properties\n# 应用名称\nspring.application.name=mybatisSpringboot\n# 数据库驱动：\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n# 数据源名称\nspring.datasource.name=defaultDataSource\n# 数据库连接地址\nspring.datasource.url=jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8\n# 数据库用户名&密码：\nspring.datasource.username=root\nspring.datasource.password=123456\n# 应用服务 WEB 访问端口\nserver.port=8080\n\nmybatis.type-aliases-package=com.xiaoliu.pojo\nmybatis.mapper-locations=classpath:/mybatis/mapper/*.xml\n```\n', 0, '2022-09-05 23:54:01', '2022-10-21 20:01:00', 0, 124, 2, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/05/9778721ff3c14ef0929cd0fb108ce8de.png', 7);
INSERT INTO `t_blog` VALUES (219, 'shiro安全框架', ' -springboot中集成', '1、导入依赖\n\n2、配置文件\n\n3、应用程序\n\n```java\n获取当前对象\nSubject currentUser = SecurityUtils.getSubject();\n获取当前session\nSession session = currentUser.getSession();\n判断用户是否被认证\ncurrentUser.isAuthenticated()\n获取当前认证\ncurrentUser.getPrincipal()    \n用户角色\ncurrentUser.hasRole  \n粗粒度    \ncurrentUser.isPermitted(\"lightsaber:wield\")\n细粒度    \ncurrentUser.isPermitted(\"winnebago:drive:eagle5\")\n登出\ncurrentUser.logout()    \n```\n\n\n\n# shiro登录认证\n\n\n\n1、创建realm对象，需要自定义类：\n\n```java\npublic class UserRealm extends AuthorizingRealm {\n\n//授权\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        System.out.println(\"授权doGetAuthorizationInfo\");\n        return null;\n    }\n//认证\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        System.out.println(\"认证doGetAuthenticationInfo\");\n        return null;\n    }\n}\n```\n\n\n\n```java\n@Configuration\npublic class shiroConfig {\n\n//    ShiroFilterFactoryBean\n//    Manager\n//    创建realm对象\n    @Bean\n    public UserRealm userRealm(){\n        return new UserRealm();\n    }\n}\n```\n\n\n\n2、defaultWebSecurityManager\n\n```java\n@Bean\n    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm){\n        DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager();\n        defaultWebSecurityManager.setRealm(userRealm);\n//        关联realm\n        return defaultWebSecurityManager;\n    }\n```\n\n\n\n3、shiroFiterFactoryBean\n\n```java\n    @Bean(name = \"DefaultWebSecurityManager\")\n    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\"DefaultWebSecurityManager\") DefaultWebSecurityManager defaultWebSecurityManager){\n        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\n//        关联webSecurityManager\n        shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager);\n        return shiroFilterFactoryBean;\n    }\n```\n\n\n\nShiroFilterFactoryBean \n\n```java\n@Bean\n    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\"securityManager\") DefaultWebSecurityManager defaultWebSecurityManager){\n        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();\n//        关联webSecurityManager\n//        设置安全管理器\n        bean.setSecurityManager(defaultWebSecurityManager);\n//        添加shiro的内置过滤器\n        /*\n            anon:无需认证\n            authc: 必须认证\n            user: 必须拥有 记住我 功能才能实现\n            perms: 拥有对某个资源权限功能才能能访问\n            role: 拥有某个角色权限\n         */\n\n        Map<String, String> filterMap = new LinkedHashMap<>();\n\n\n        filterMap.put(\"/user/add\",\"authc\");\n        filterMap.put(\"/user/update\",\"authc\");\n        System.out.println(\"filterMap\");\n\n       bean.setFilterChainDefinitionMap(filterMap);\n        return bean;\n    }\n```\n\n\n\n可在ShiroFilterFactoryBean 设置登录\n\n`bean.setLoginUrl(\"/toLogin\");`                        \n\n\n\n# shiro实现用户认证\n\n在Controller中\n\n```java\n@RequestMapping(\"/login\")\n    public String login(String username,String password){\n        //        获取对象\n        Subject subject = SecurityUtils.getSubject();\n\n//        封装登录对象的数据为token\n        UsernamePasswordToken token = new UsernamePasswordToken(username, password);\n                subject.login(token);\n        try {\n            subject.login(token);//执行登录方法，无异常就执行\n            return \"index\";\n        } catch (UnknownAccountException e) {//用户名不存在\n            model.addAttribute(\"msg\",\"用户名错误\");\n            return \"login\";\n        } catch (IncorrectCredentialsException e){//密码不存在\n            model.addAttribute(\"msg\",\"密码错误\");\n            return \"login\";\n        } catch (LockedAccountException e){\n            model.addAttribute(\"msg\",\"账号被锁定\");\n            return \"login\";\n        }\n    }\n```\n\n\n\nUserRealm类中\n\n```java\n@Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        System.out.println(\"认证doGetAuthenticationInfo\");\n\n//        用户名，密码，数据库中取\n        String username= \"root\";\n        String password= \"123456\";\n        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;\n        if (!token.getUsername().equals(username)){\n            return null;//抛出异常UnknownAccountException\n        }\n//        密码认证shiro做\n        return new SimpleAuthenticationInfo(\"\",password,\"\");\n    }\n```\n\n\n\n# Shiro整合Mybatis\n\n搭建脚手架并测试，通过再进行下面的测试\n\n\n\n在UserRealm中导入业务层接口\n\n```java\n@Autowired\nUserService userService;\n```\n\n```java\n//      连接数据库\n        UsernamePasswordToken userToken = (UsernamePasswordToken) authenticationToken;\n        User user = userService.queryUserByName(userToken.getUsername());\n\n        if (user==null){\n            //查无此人\n            return null;//UnknownAccountException\n        }\n\n//        密码认证shiro做\n        return new SimpleAuthenticationInfo(\"\",user.getPassword(),\"\");\n    }\n```\n\n\n\nUserRealm类中\n\n```java\n//      连接数据库\n        UsernamePasswordToken userToken = (UsernamePasswordToken) authenticationToken;\n        User user = userService.queryUserByName(userToken.getUsername());\n\n        if (user==null){\n            //查无此人\n            return null;//UnknownAccountException\n        }\n\n//        加密：MD5加密，MD5盐值加密\n//        md5：xwefqbrb134513451223qwer md5+盐值： xwefqbrb134513451223qwerusername\n//        密码认证shiro做，加密了\n//        密码认证shiro做\n        return new SimpleAuthenticationInfo(\"\",user.getPassword(),\"\");\n    }\n```\n\n\n\n# Shiro请求授权实现\n\n 在shiroConfig类中\n\n```java\n//        授权\n        filterMap.put(\"/user/add\",\"perms[user:add]\");\n```\n\n\n\n设置未授权的请求\n\n```java\n//       设置未授权的请求\n       bean.setUnauthorizedUrl(\"/noauth\");\n```\n\n\n\n设置Controller\n\n```java\n@RequestMapping(\"/noauth\")\n@ResponseBody\npublic String unauthorized(){\n        return \"未经授权无法访问该页面\";\n}\n```\n\n编写controller层\n\n```java\n@RequestMapping(\"/noauth\")\n@ResponseBody\npublic String unauthorized(){\n        return \"未经授权无法访问该页面\";\n}\n```\n\n\n\n## 授权、\n\n```java\n//授权\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        System.out.println(\"授权doGetAuthorizationInfo\");\n        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n        info.addStringPermission(\"user:add\");//这行是全部人都获取授权，想指定的人获得授权就注释这行\n        return info;\n    }\n```\n\n\n\n指定数据库中的某些用户获取数据\n\n数据库中设定权限\n\nUserRealm类中\n\n```java\n//      拿到当前登录的对象\n        Subject subject = SecurityUtils.getSubject();\n        User currentUser = (User)subject.getPrincipal();//拿到user对象\n\n        info.addStringPermission(currentUser.getPerms());\n        return info;\n```\n\n\n\nshiroConfig类中\n\n```java\nfilterMap.put(\"/user/add\",\"perms[user:add]\");\nfilterMap.put(\"/user/update\",\"perms[user:update]\");\n```\n\n\n\n# Shiro整合Thymeleaf\n\n导入依赖 shiro-thymeleaf\n\n```xml\n<dependency>\n  <groupId>com.github.theborakompanioni</groupId>\n  <artifactId>thymeleaf-extras-shiro</artifactId>\n  <version>2.1.0</version>\n</dependency>\n```\n\n\n\n在UserRealm类中\n\n```java\n//    整合shirodialect：整合 th 和 shiro\n    @Bean\n    public ShiroDialect getshiroDialect(){\n        return new ShiroDialect();\n    }\n```\n', 0, '2022-09-05 23:56:02', '2022-10-21 20:01:00', 0, 1, 1, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/05/7f219334334743aeb966780fd9e0365b.jpeg', 7);
INSERT INTO `t_blog` VALUES (220, 'swagger', 'Swagger简介', 'Swagger简介\n\n前后端分离\n\nVue + SpringBoot\n\n# Swagger\n\n最流行的API框架\n\n\n\n在项目中使用swagger需要springfox；\n\n* swagger2\n* ui\n\n\n\n# spirngboot集成swagger\n\n\n\n1、新建springweb项目\n\n2、导入依赖\n\n\n\n```xml\n<dependency>\n  <groupId>io.springfox</groupId>\n  <artifactId>springfox-swagger2</artifactId>\n  <version>3.0.0</version>\n</dependency>\n```\n\n\n\n```xml\n<dependency>\n  <groupId>io.springfox</groupId>\n  <artifactId>springfox-swagger-ui</artifactId>\n  <version>3.0.0</version>\n</dependency>\n```\n\n\n\n3、配置swagger\n\n```JAVA\n@Configuration\n@EnableSwagger2//开启swagger2\npublic class SwaggerConfig {\n}\n```\n\n测试页面\n\n**http://localhost:8080/swagger-ui.html**\n\n\n\nswagger的bean实例 Docket\n\nSwaggerConfig\n\n```java\npackage com.xiaoliu.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.RequestHandler;\nimport springfox.documentation.builders.RequestHandlerSelectors;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.service.Contact;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\nimport java.util.ArrayList;\n\n/**\n * @author: 61分\n * @date: 2022/4/22 17:39\n * @description:\n */\n\n@Configuration\n@EnableSwagger2//开启swagger2\npublic class SwaggerConfig {\n\n//    配置swagger的Docket bean实例\n    @Bean\n    public Docket docket(){\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo())\n    }\n\n//    配置swagger信息=apiinfo\n    private ApiInfo apiInfo(){\n        System.out.println(\"doswagger\");\n//        作者信息\n        Contact contact = new Contact(\"xiaoliu\", \"https://dddwah11.github.io/\", \"1937589397@qq.com\");\n\n        return new ApiInfo(\n                \"APIInfo\",\n                \"swagger配置\",\n                \"v1.0\",\n                \"https://dddwah11.github.io/\",\n                contact,\n                \"Apache 2.0\",\n                \"http://www.apache.org/licenses/LINCENSE-2.0\",\n                new ArrayList<>()\n        );\n    }\n}\n```\n\n\n\n# Swagger配置扫描接口\n\nDocket.select()\n\n```java\n				.enable(false);//\n				.select()\n//                RequestHandlerSelectors配置需要扫描接口的方式\n//                basePackage指定要扫描的包\n//                any()扫描全部\n//                none()都不扫描\n//               withClassAnnotation;扫描类上的注解，参数是一个注解的反射对象\n//                withMethodAnnotation;扫描方法上的注解\n                    .apis(RequestHandlerSelectors.basePackage(\"com.xiaoliu.helloController\"))\n//                path()过滤路径\n\n                .build();\n```\n\n\n\n配置是否启动swagger\n\n```java\n			.enable(false);//不启动swagger\n			.select()\n```\n\n\n\n我们希望swagger在生产环境中使用，在发布时不使用\n\n* 判断是不是生产环境 \n* 注入 enable()\n\n```java\n    @Bean\n    public Docket docket(Environment environment){\n//        设置要显示的flag环境\n        Profiles profiles =Profiles.of(\"dev\",\"test\");\n//        获取项目环境\n//        通过environment.acceptsProfiles判断是否处在自己设定的环境\n        boolean b = environment.acceptsProfiles(profiles);\n\n\n\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo())\n                .enable(b)\n```\n\n配置文件中设置生产和发布环境\n\n主配置文件设置\n\n```xml\nspring.profiles.active=当前环境\n```\n\n\n\n# swagger配置API文档分组\n\n```java\n.apiInfo(apiInfo())\n.groupName(\"hello\")\n```\n\n如何配置多个分组\n\n\n\n```java\n@Bean\npublic Docket docket1(){\n    return new Docket(DocumentationType.SWAGGER_2).groupName(\"A\");\n}\n```\n\n`@ApiModel()//文档注释`\n', 0, '2022-09-05 23:57:02', '2022-10-21 20:01:00', 0, 1, 1, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/05/da643815927745dc895569fa5d86daad.jpg', 7);
INSERT INTO `t_blog` VALUES (221, '任务', 'springboot', '#   异步任务\n\n在业务需要异步处理的方法加入注解 `@Async`\n\n在启动类加入 `@EnableAsync`\n\n在控制层加入加入业务即可\n\n\n\n# 邮件任务\n\n这里用qq邮件\n\n配置文件\n\n```properties\n#开启加密验证\nspring.mail.properties.mail.smtp.ssl.enable=true\n\nspring.mail.username=1937589397@qq.com\nspring.mail.password=ixxxxxxxxxxb\nspring.mail.host=smtp.qq.com\n```\n\n\n\n```java\n@Autowired\n    JavaMailSender mailSender;\n\n    @Test\n    void contextLoads() {\n//        发送邮件\n//        发件人\n//        内容\n        SimpleMailMessage message = new SimpleMailMessage();\n        message.setSubject(\"小刘\");\n        message.setText(\"hello\");\n\n        message.setFrom(\"1937589397@qq.com\");\n        message.setTo(\"1937589397@qq.com\");\n\n        mailSender.send(message);\n\n    }\n```\n\n复杂邮件\n\n\n\n```java\n MimeMessage mimeMessage = mailSender.createMimeMessage();\n//        组装\n        MimeMessageHelper helper = new MimeMessageHelper(mimeMessage,true);\n\n        helper.setSubject(subject);\n        helper.setText(text,true);\n\n//        附件\n        helper.addAttachment(\"1.jpg\",new File(\"D:\\\\壁纸\\\\5b8b4cf6143640c98cd46cd77d26f292.jpg\"));\n\n        helper.setTo(\"1937589397@qq.com\");\n        helper.setFrom(\"1937589397@qq.com\");\n\n        mailSender.send(mimeMessage);\n```\n\n\n\n# 定时执行任务\n\n\n\n```java\nTaskeScheduler 任务调度者\n\nTaskExecutor 认为执行者\n\n@EnableScueduling开启定时功能的注解在启动类\n@Scheduled 什么时候执行\n    \nCron表达式\n```\n\n```java\n@Service\npublic class ScheduleService {\n\n//    cron表达\n//    秒 分 时 日 月 周几\n//    下面表达式表示是 每一周的每0秒执行\n//@Scheduled(cron = \"0 * * * * 0-7\")\n//    下面表达的是 每一天天的16时 44分 执行\n    @Scheduled(cron = \"1 48 16 * * ?\")\n//    30 0/5 10 18, * ? 每天 10点和18点 每隔五分钟执行一次\n    public void hello(){\n        System.out.println(\"您被执行了\");\n    }\n}\n```', 0, '2022-09-05 23:58:14', '2022-10-21 20:01:00', 0, 125, 1, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/05/791d859103b441eabef0efde6019845f.jpg', 7);
INSERT INTO `t_blog` VALUES (222, '分布式-Dubbo-Zookeeper', '分布式系统理论', '# 安装zookeeper\n\nhttps://archive.apache.org/dist/zookeeper/zookeeper-3.7.0/\n\n下载编译后二进制的包\n\n运行bin目录下的zkServer.cmd windows下\n\n闪退解决：修改配置文件 加个暂停(pause)查看错误的原因\n\n原因是conf目录下没有 zoo.cfg 复制sample进行添加\n\n\n\n连接服务zkServer.cmd\n\n连接客户端zkCli.cmd\n\n\n\n在项目中打包dubbo-admin\n\n`mvn clean package -Dmaven.test.skip=true`\n\nadmin的地址为7001\n\n默认账号密码都是 root\n\n\n\ndubbo-admin是一个监控管理后台，查看我们哪些服务注册，被消费\n\nzookeeper是 注册中心\n\n\n\n\n\n导入依赖\n\n```xml\n<dependency>\n  <groupId>com.github.sgroschupf</groupId>\n  <artifactId>zkclient</artifactId>\n  <version>0.1</version>\n</dependency>\n```\n\n\n\n```xml\n<dependency>\n  <groupId>org.apache.dubbo</groupId>\n  <artifactId>dubbo-spring-boot-starter</artifactId>\n  <version>2.7.3</version>\n</dependency>\n```\n\n日志冲突\n\n```\n<dependency>\n    <groupId>org.apache.dubbo</groupId>\n    <artifactId>dubbo-spring-boot-starter</artifactId>\n    <version>2.7.3</version>\n\n    <exclusions>\n        <exclusion>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n```\n\n配置文件\n\n```properties\n#服务应用名字\ndubbo.application.name=provider\n#注册中心地址\ndubbo.registry.address=zookeeper://127.0.1:2181\n#哪些服务需要被注册\ndubbo.scan.base-packages=com.xiaoliu.service\n```\n\n\n\n接下来再导入依赖\n\n```xml\n<dependency>\n  <groupId>org.apache.curator</groupId>\n  <artifactId>curator-recipes</artifactId>\n  <version>2.12.0</version>\n</dependency>\n```\n\n\n\n```xml\n<dependency>\n  <groupId>org.apache.zookeeper</groupId>\n  <artifactId>zookeeper</artifactId>\n  <version>3.4.14</version>\n  <type>pom</type>\n</dependency>\n```\n\n这个需要排除sl4j的依赖\n\n\n\n```properties\n#消费者需要去哪拿服务需要暴露名字\n\ndubbo.application.name=provider\n\n#去注册中心\n\ndubbo.registry.address=zookeeper://127.0.1:2181\n```\n\n\n\n消费者业务接口\n\n```java\n消费者生产者接口都必须相同\n    @Service\npublic class Service{\n    @Reference//引用，Pom坐标，可以定义路径相同的接口名，远程引用\n    TicketService ticketService;\n    \n    public void buyTicket(){\n        String ticket = ticketService.getTicket();\n        System.out.println(\"拿到票\"+ticket);\n    }\n}\n\n```\n\n\n\n1、提供者提供服务\n\n​	1.导入依赖\n\n​	2.配置注册中心地址，以及服务发现名，和要扫描的包\n\n​	3.在想要被注册的服务上面 增加一个注解 @Service\n\n2、消费者如何消费\n\n​	1.导入依赖\n\n​	2.配置注册中心地址，配置自己的服务名\n\n​	3.从远程注入服务 @Reference\n', 0, '2022-09-05 23:59:08', '2022-10-21 20:01:00', 0, 1, 2, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/05/b2dbd1ad509842c7a51f30a94c0fbddb.jpg', 7);
INSERT INTO `t_blog` VALUES (223, 'Vue', 'vue初学', '网络通信: axios\n\n网页跳转：vue_router\n\n状态管理：vuex\n\nVue-UI: ICE ElementUI、\n\nUI框架：iview Ant-Design、Bootstrap AmazeUI、layui、**vue-element-admin**\n\nJavaScript构建工具： **WebPack**:打包、压缩、合并、按序加载\n\n\n\n# MVVM模型\n\n* view\n* model\n* view model\n\n\n\n# 条件判断\n\n```html\n<div id=\"app\">\n<li v-for=\"item in items\">\n    {{item.message}}\n</li>\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js\"></script>\n<script>\n    var vm = new Vue({\n        el:\"#app\",\n        data: {\n            items: [\n    {message: \'xiaoliu\'},\n    {message: \'xiaoliuu\'}\n            ]\n        }\n    });\n</script>\n</body>\n```\n\n\n\n# 鼠标悬停\n\n```html\n<div id=\"app\">\n    <span v-bind:title=\"message\">\n        鼠标悬停几秒查看此处动态绑定的提示消息!\n</span>\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js\"></script>\n<script>\n    var vm = new Vue({\n        el:\"#app\",\n        data:{\n            message:\"hello,vue\"\n        }\n\n    });\n</script>\n```\n\n\n\n#  事件\n\n```html\n<div id=\"app\">\n    <button v-on:click=\"sayHi\">点我</button>\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js\"></script>\n<script>\n    var vm = new Vue({\n        el:\"#app\",\n        data: {},\n        methods: { //方法必须定义在methods方法对象中\n            sayHi: function () {\n                alert(this.message)\n            }\n        }\n    });\n</script>\n```\n\n\n\n# Vue7大属性\n\n**1.el属性**\n\n用来指示vue编译器从什么地方开始解析 vue的语法，可以说是一个占位符。\n相当于一个容器，跟上面的div id = \"app\"做关联，从此以后上面div id = \"app\"里面的内容要通过vue来渲染,都要经过vue处理才能看得到上面div里面的内容\n\n**2.data属性**\n用来组织从view中抽象出来的属性，可以说将视图的数据抽象出来存放在data中。\n跟微信小程序一样，所有的变量都要写在data里面\n\n**3.template属性**\n用来设置模板，会替换页面元素，包括占位符。\nVue.component（）组件中会用到，其实很多地方都会用到\n\n**4.methods属性**\n放置页面中的业务逻辑，js方法一般都放置在methods中，用来写方法，函数的\ncomputed后面会介绍\ncomputed和methods是有区别的：computed是在值发生改变的时候才会触发效果，而methods只要刷新执行了就会触发，所有平时写VUE的时候，能用computed的尽量使用\n\n**5.render属性**\n创建真正的Virtual Dom\n\n**6.computed属性**\n用来计算\n根据已经存在的属性计算出新的属性，对于同样的数据，会缓存。当其依赖属性的值发生变化是，这个属性的值会自动更新，与之相关的DOM部份也会同步自动更新。其实一般情况，我也会把一些关于逻辑的代码都写在computed中。\n\n**7.watch侦听属性**\nwatch:function(new,old){}\n监听data中数据的变化\n两个参数，一个返回新值，一个返回旧值\n当你有一些数据需要随着其它数据变动而变动时或者执行异步操作或开销较大操作时，建议使用watch\ncomputed和watch是有区别的：\nwatch: 监视,能够监听到数据的变化,只要数据变化的时候,都会自定执行对应的方法,其中可以检测的数据来源分为三部分 data , computed , props computed: 计算属性,存在一个计算缓存的特性,每一次计算之后,只要里面的逻辑不发生变化,每一次重复调用,都会使用上一次执行的结果,能够节省计算的时间\n\n\n\n在表单实现数据的双向绑定\n\n```html\n<div id=\"app\">\n    <textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\" v-model=\"message\"></textarea>\n    {{message}}\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js\"></script>\n<script>\n    var vm = new Vue({\n        el:\"#app\",\n        data: {\n            message:\'\'\n        },\n    });\n</script>\n```\n\n\n\n**同步输入框**\n\n```html\n<div id=\"app\">\n    性别：\n    <input type=\"radio\"  name=\"sex\" value=\"男\" v-model=\"message\"> 男\n    <input type=\"radio\" name=\"sex\" value=\"女\" v-model=\"message\"> 女\n    <p>选中了：{{message}}</p>\n</div>\n\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js\"></script>\n<script>\n    var vm = new Vue({\n        el:\"#app\",\n        data: {\n            message:\'\'\n        },\n    });\n</script>\n```\n\n\n\n# 组件\n\n自定义组件获取值：\n\n```html\n<div id=\"app\">\n<xiaoliu v-for=\"item in items\" v-bind:item=\"item\"></xiaoliu>\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js\"></script>\n<script>\n    Vue.component(\"xiaoliu\",{\n        props: [\'item\'],\n        template: \'<h1>{{item}}</h1>\' //模板\n    })\n    var vm = new Vue({\n        el:\"#app\",\n        data: {\n            message:\'\',\n            items: [\"xiaoliu\",\"xiaoliuu\",\"xiaoliuuu\"]\n        },\n    });\n</script>\n```\n\n\n\n# Axios异步通信\n\njson数据：\n\n```json\n{\n  \"name\":\"狂神说java\",\n  \"url\": \"http://baidu.com\",\n  \"page\": \"1\",\n  \"isNonProfit\":\"true\",\n  \"address\": {\n    \"street\": \"含光门\",\n    \"city\":\"陕西西安\",\n    \"country\": \"中国\"\n  },\n  \"links\": [\n    {\n      \"name\": \"B站\",\n      \"url\": \"https://www.bilibili.com/\"\n    },\n    {\n      \"name\": \"4399\",\n      \"url\": \"https://www.4399.com/\"\n    },\n    {\n      \"name\": \"百度\",\n      \"url\": \"https://www.baidu.com/\"\n    }\n  ]\n\n```\n\n\n\n```html\n<!--导入JS文件-->\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"></script>\n<script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n<script type=\"text/javascript\"></script>\n```\n\n\n\n```html\n<div id=\"vue\"></div>\n<!--导入JS文件-->\n<script src=\"https://cdn.jsdelivr.net/nmp/vue@2.5.21/dist/vue.js\"></script>\n<script src=\"https://unpkg.com/axios/dist/axios.min .js\"></script>\n<script type=\"text/javascript\">\n    var vm = new Vue({\n        el: \"#vue\",\n        data(){\n            return{\n                info:{\n                    name:null,\n                    address:{\n                        street:null,\n                        city: null,\n                        country: null\n                    }\n                }\n            }\n        },\n        mounted(){//钩子函数，链式编程\n            axios.get(\'data.json\').then(response=>(this.info=response.data));\n        }\n    });\n</script>\n```\n\n\n\n**解决数据闪烁问题**\n\n```html\n<style>\n    [v-clock]{\n        display: none;\n    }\n</style>\n```\n\n在head标签内，没加载数据时白屏\n\n\n\n# 计算属性\n\n```vue\ncomputed:{//计算属性 methods computed中能重名，优先调用方法\n    currentTime1: function () {\n        return Date.now();\n    }\n}\n```\n\n返回的是属性\n\n\n\n# slot（插槽）\n\n```html\n<div id=\"vue\">\n    <todo>\n        <todo-title slot=\"todo-title\" :title=\"title\"></todo-title>\n        <todo-item slot=\"todo-item\" v-for=\"items in item\" :item=\"items\"></todo-item>\n    </todo>\n</div>\n<!--导入JS文件-->\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"></script>\n<script type=\"text/javascript\">\n    Vue.component(\"todo\",{\n        template:\n            \'<div>\' +\n            \'<slot name=\"todo-title\"></slot>\' +\n             \'<ul>\' +\n            \'<slot name=\"todo-item\"></slot>\' +\n            \'</ul>>\'               +\n                \'</div>\'\n    });\n    Vue.component(\"todo-title\",{\n        props: [\'title\'],\n        template: \'<div>{{title}}</div>\'\n    });\n    Vue.component(\"todo-item\",{\n        props: [\'item\'],\n        template: \'<div>{{item}} <button @click=\"remove\">删除</button> </div>\',\n        methods: {\n            remove: function () {\n                alert(\"删除成功\")\n            }\n        }\n    });\n    var vm = new Vue({\n        el: \"#vue\",\n        data: {\n            title: \"xiaoliu\",\n            todo: [\'效率\',\'小刘\'],\n            item: [\'wo\',\'we\']\n        }\n    });\n</script>\n```\n\n\n\n\n\n# 自定义事件\n\n删除操作要在组件中完成，涉及参数传递与事件分发，可以使用this.$emit( \' 自定义事件名 \' , 参数)\n\n![image-20220426181505853](image-20220426181505853.png)\n\n```html\n<div id=\"vue\">\n    <todo>\n        <todo-title slot=\"todo-title\" :title=\"title\"></todo-title>\n        <todo-item slot=\"todo-item\" v-for=\"(items,index) in item\"\n                   :item=\"items\" v-bind:index=\"index\" v-on:remove=\"removeItem(index)\" :key=\"index\"></todo-item>\n    </todo>\n</div>\n<!--导入JS文件-->\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"></script>\n<script type=\"text/javascript\">\n    Vue.component(\"todo\",{\n        template:\n            \'<div>\' +\n            \'<slot name=\"todo-title\"></slot>\' +\n             \'<ul>\' +\n            \'<slot name=\"todo-item\"></slot>\' +\n            \'</ul>>\'               +\n                \'</div>\'\n    });\n    Vue.component(\"todo-title\",{\n        props: [\'title\'],\n        template: \'<div>{{title}}</div>\'\n    });\n    Vue.component(\"todo-item\",{\n        props: [\'item\',\'index\'],\n        template: \'<div>{{index}}----{{item}} <button @click=\"remove\">删除</button> </div>\',\n        methods: {\n            remove: function (index) {\n                this.$emit(\'remove\',index);\n            }\n        }\n    });\n    var vm = new Vue({\n        el: \"#vue\",\n        data: {\n            title: \"xiaoliu\",\n            todo: [\'效率\',\'小刘\'],\n            item: [\'wo\',\'we\']\n        },\n        methods: {\n            removeItem: function (index) {\n                console.log(\"shanchu\"+this.item[index]+\"ok\");\n                this.item.splice(index,1);\n            }\n        }\n    });\n</script>\n```', 0, '2022-09-05 23:59:51', '2022-10-21 20:01:00', 0, 119, 8, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/05/7f16673157f44ee295bf41ba4713c960.jpg', 7);
INSERT INTO `t_blog` VALUES (224, '大二下javaweb项目', '初学项目', '# 1、配置\n\n## 1.1、相关依赖\n\n父项目pom.xml中的版本控制\n\n```xml\n    <properties>\n<!--        mybatis-plus-->\n        <mp.version>3.5.0</mp.version>\n<!--        mybatis-plus-generator-->\n        <mpg.version>3.4.0</mpg.version>\n<!--        swagger-->\n        <swagger.version>2.9.2</swagger.version>\n<!--        velocity模板引擎-->\n        <velocity.version>2.3</velocity.version>\n<!--        mysql-->\n        <mysql-java.version>8.0.28</mysql-java.version>\n<!--        lombok-->\n        <lombok.version>1.18.22</lombok.version>\n<!--        knife4j增强文本-->\n        <knife4j.version>2.0.7</knife4j.version>\n            </properties>\n```\n\n**依赖**\n\n```xml\n<!--            mybatis-plus-->\n            <dependency>\n                <groupId>com.baomidou</groupId>\n                <artifactId>mybatis-plus-boot-starter</artifactId>\n                <version>${mp.version}</version>\n            </dependency>\n\n<!--            swagger ui-->\n            <dependency>\n                <groupId>io.springfox</groupId>\n                <artifactId>springfox-swagger-ui</artifactId>\n                <version>${swagger.version}</version>\n            </dependency>\n\n<!--            swagger2-->\n            <dependency>\n                <groupId>io.springfox</groupId>\n                <artifactId>springfox-swagger2</artifactId>\n                <version>${swagger.version}</version>\n            </dependency>\n\n<!--            mysql数据库-->\n            <dependency>\n                <groupId>mysql</groupId>\n                <artifactId>mysql-connector-java</artifactId>\n                <version>${mysql-java.version}</version>\n            </dependency>\n\n<!--            mybatis-plus模板引擎-->\n            <dependency>\n                <groupId>org.apache.velocity</groupId>\n                <artifactId>velocity-engine-core</artifactId>\n                <version>${velocity.version}</version>\n            </dependency>\n<!--            代码自动生成-->\n            <dependency>\n            <groupId>com.baomidou</groupId>\n            <artifactId>mybatis-plus-generator</artifactId>\n            <version>${mpg.version}</version>\n            </dependency>\n\n<!--            lombok-->\n            <dependency>\n                <groupId>org.projectlombok</groupId>\n                <artifactId>lombok</artifactId>\n                <version>${lombok.version}</version>\n            </dependency>\n\n<!--            knife4j-->\n            <dependency>\n                <groupId>com.github.xiaoymin</groupId>\n                <artifactId>knife4j-spring-bootstarter</artifactId>\n                <version>${knife4j.version}</version>\n            </dependency>\n```\n\n## 1.2、创建两个子maven项目\n\n### web（springboot项目）\n\n* **依赖于commons项目**\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>com.xiaoliu</groupId>\n        <artifactId>helovue-base-common</artifactId>\n        <version>0.0.1-SNAPSHOT</version>\n    </dependency>\n</dependencies>\n```\n\n* **配置文件**\n\n```yaml\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/xinguan?useUnicode=true&serveTimezone=UTC&useSSL=false&characterEncoding=utf8\n    username: root\n    password: 123456\n  jackson:\n      date-format: yyyy-MM-dd HH:mm:ss\n      time-zone: GMT+8\n\n\n\n\nserver:\n  port: 8081\nmybatis-plus:\n  configuration:\n    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl\n  global-config:\n    db-config:\n      logic-delete-field: deleted # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)\n      logic-delete-value: 1 # 逻辑已删除值(默认为 1)\n      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)\n  mapper-locations: classpath*:/mapper/*.xml\n```\n\n启动类：\n\n```java\n@SpringBootApplication\n@MapperScan(\"com.xiaoliu.system.mapper\")\n@EnableSwagger2\npublic class xitongApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(xitongApplication.class,args);\n    }\n}\n```\n\n\n\n### base-common(设置配置等统一处理)\n\n依赖于父项目\n\n```xml\n<dependencies>\n        <dependency>\n            <!--            controller层-->\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <!--        数据访问层-->\n        <dependency>\n            <groupId>com.baomidou</groupId>\n            <artifactId>mybatis-plus-boot-starter</artifactId>\n        </dependency>\n\n        <!--        mybatis自动代码生成-->\n        <dependency>\n            <groupId>com.baomidou</groupId>\n            <artifactId>mybatis-plus-generator</artifactId>\n        </dependency>\n\n        <!--        mybatis-plus模板引擎-->\n        <dependency>\n            <groupId>org.apache.velocity</groupId>\n            <artifactId>velocity-engine-core</artifactId>\n        </dependency>\n\n        <!--        java连接mysql-->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\n        <!--        swagger2-->\n        <dependency>\n            <groupId>io.springfox</groupId>\n            <artifactId>springfox-swagger2</artifactId>\n        </dependency>\n\n        <!--        swaggerui-->\n        <dependency>\n            <groupId>io.springfox</groupId>\n            <artifactId>springfox-swagger-ui</artifactId>\n        </dependency>\n\n        <!--        lombok-->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n        </dependency>\n\n<!--        knife4j-->\n        <dependency>\n            <groupId>com.github.xiaoymin</groupId>\n            <artifactId>knife4j-spring-boot-starter</artifactId>\n        </dependency>\n    </dependencies>\n```\n\n# 2、自动生成代码\n\n## 2.1、需要依赖（配置时已导入）\n\nmybatis-plus(持久层框架)、velocity(mybatis-plus模板引擎)、mybatis-plus-generator(代码自动生成)\n\n**CodeGenerator.java**\n\n```java\npublic class CodeGenerator {\n\n    /**\n     * <p>\n     * 读取控制台内容\n     * </p>\n     */\n    public static String scanner(String tip) {\n        Scanner scanner = new Scanner(System.in);\n        StringBuilder help = new StringBuilder();\n        help.append(\"请输入\" + tip + \"：\");\n        System.out.println(help.toString());\n        if (scanner.hasNext()) {\n            String ipt = scanner.next();\n            if (StringUtils.isNotBlank(ipt)) {\n                return ipt;\n            }\n        }\n        throw new MybatisPlusException(\"正确的\" + tip + \"！\");\n    }\n\n    public static void main(String[] args) {\n        // 创建代码生成器对象\n        AutoGenerator mpg = new AutoGenerator();\n\n        // 全局配置\n        GlobalConfig gc = new GlobalConfig();\n        gc.setOutputDir(scanner(\"你的项目路径\") + \"/src/main/java\");\n        gc.setAuthor(\"xiaoliu\");\n//        生成之后是否打开资源管理器\n        gc.setOpen(false);\n//        是否覆盖文件\n        gc.setFileOverride(false);\n//        %s占位符\n//        mp生成service层代码，默认的接口名称第一张字母是有I\n        gc.setServiceName(\"%sService\");\n//        设置主键生成策略 自动增长\n        gc.setIdType(IdType.AUTO);\n//        设置date的类型 默认只使用 java.util.date 代替\n        gc.setDateType(DateType.ONLY_DATE);\n        //开启实体属性 Swagger2 注解\n         gc.setSwagger2(true);\n        mpg.setGlobalConfig(gc);\n\n        // 数据源配置\n        DataSourceConfig dsc = new DataSourceConfig();\n        dsc.setUrl(\"jdbc:mysql://localhost:3306/xinguan?useUnicode=true&serveTimezone=UTC&useSSL=false&characterEncoding=utf8\");\n        dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\");\n        dsc.setUsername(\"root\");\n        dsc.setPassword(\"123456\");\n//        设置数据库类型\n        dsc.setDbType(DbType.MYSQL);\n        mpg.setDataSource(dsc);\n\n        // 包配置\n        PackageConfig pc = new PackageConfig();\n        pc.setModuleName(scanner(\"模块名\"));\n        pc.setParent(\"com.xiaoliu\");\n        //        设置包\n        pc.setController(\"controller\");\n        pc.setService(\"service\");\n        pc.setServiceImpl(\"service.impl\");\n        pc.setMapper(\"mapper\");\n        pc.setEntity(\"pojo\");\n        pc.setXml(\"mapper\");\n        mpg.setPackageInfo(pc);\n\n\n\n\n        // 策略配置\n        StrategyConfig strategy = new StrategyConfig();\n//设置哪些表需要自动生成\n        strategy.setInclude(scanner(\"表名，多个英文逗号分割\").split(\",\"));\n//实体类名称驼峰命名\n        strategy.setNaming(NamingStrategy.underline_to_camel);\n//        列名驼峰命名\n        strategy.setColumnNaming(NamingStrategy.underline_to_camel);\n//        使用lombok模型\n        strategy.setEntityLombokModel(true);\n//        使用restful风格设置api\n        strategy.setRestControllerStyle(true);\n\n//驼峰转连字符\n        strategy.setControllerMappingHyphenStyle(true);\n//        strategy.getFieldPrefix(\"前缀\"); 可忽略表中的前缀\n        mpg.setStrategy(strategy);\n        mpg.execute();\n    }\n\n}\n```\n\n# 3、统一返回结果\n\n在common项目的response目录下\n\n**接口**\n\n**CustomizeResultCode**\n\n```java\npackage com.xiaoliu.response;\n\n/**\n * @author: 61分\n * @date: 2022/5/7 12:52\n * @description:\n */\npublic interface CustomizeResultCode {\n    /**\n     * 返回错误码\n     * @return\n     */\n    Integer getCode();\n\n    /**\n     * 返回错误信息\n     * @return\n     */\n    String  getMessage();\n}\n```\n\n\n\n**枚举类**（保护属性）\n\n**ResultCode**\n\n```java\npublic enum ResultCode implements CustomizeResultCode{\n    /**\n     * 20000，成功\n     */\n    SUCCESS(20000,\"成功\"),\n\n    /**\n     * 20001，失败\n     */\n    ERROR(20001,\"失败\"),\n\n    /**\n     * 20002，算术异常\n     */\n    ARITHMETICEXCEPTION(20002,\"算术异常\"),\n\n    /**\n     * 20003，用户不存在\n     */\n    USER_NOFOUND_EXCEPTION(20003,\"用户不存在\"),\n\n\n    ;\n\n    private Integer code;\n    private String message;\n\n    ResultCode(Integer code,String message){\n        this.code = code;\n        this.message = message;\n    }\n\n    @Override\n    public Integer getCode() {\n        return code;\n    }\n\n    @Override\n    public String getMessage() {\n        return message;\n    }\n}\n```\n\n\n\n**实现类**\n\n**Result**\n\n```java\n/**\n * @author: 61分\n * @date: 2022/5/7 13:00\n * @description:公共返回结果\n */\n@Data\npublic class Result {\n\n    @ApiModelProperty(value = \"是否成功\")\n    private boolean success;\n\n    @ApiModelProperty(value = \"返回码\")\n    private Integer code;\n\n    @ApiModelProperty(value = \"返回消息\")\n    private String message;\n\n    @ApiModelProperty(value = \"返回的数据\")\n    private Map<String,Object> data =  new HashMap<>();\n\n    /**\n     * 构造方法私有，保护属性\n     */\n    private Result(){};\n\n    public static Result ok(){\n        Result result = new Result();\n        result.setSuccess(true);\n        result.setCode(ResultCode.SUCCESS.getCode());\n        result.setMessage(ResultCode.SUCCESS.getMessage());\n        return result;\n    }\n\n//    使用链式编程\n    public static Result error(){\n        Result result = new Result();\n        result.setSuccess(false);\n        result.setCode(ResultCode.ERROR.getCode());\n        result.setMessage(ResultCode.ERROR.getMessage());\n        return result;\n    }\n\n    /**\n     * 自定义返回\n     * @param success\n     * @return\n     */\n    public Result success(Boolean success){\n        this.setSuccess(success);\n        return this;\n    }\n\n    public Result message(String message){\n        this.setMessage(message);\n        return this;\n    }\n\n    public Result code(Integer code){\n        this.setCode(code);\n        return this;\n    }\n\n    public Result data(String key,Object value){\n        this.data.put(key, value);\n        return this;\n    }\n\n    public Result data(Map<String,Object> map){\n        this.setData(map);\n        return this;\n    }\n\n}\n```\n\n# 4、统一异常处理\n\ncommon项目的handler目录下\n\n**全局的异常处理**\n\n**GlobalExceptionHandler**\n\n```java\n/**\n * @author: 61分\n * @date: 2022/5/7 14:52\n * @description:统一异常处理\n */\n@ControllerAdvice\n@Slf4j\npublic class GlobalExceptionHandler {\n    @ExceptionHandler(Exception.class)\n    @ResponseBody\n    public Result error(Exception e) {\n        log.error(e.getMessage());\n        return Result.error();\n    }\n\n    @ExceptionHandler(ArithmeticException.class)\n    @ResponseBody\n    public Result error(ArithmeticException e) {\n        log.error(e.getMessage());\n        return Result.error().code(ResultCode.ARITHMETICEXCEPTION.getCode())\n                .message(ResultCode.ARITHMETICEXCEPTION.getMessage());\n    }\n\n    @ExceptionHandler(BusinessException.class)\n    @ResponseBody\n    public Result error(BusinessException e) {\n        log.error(e.getErrMsg());\n        return Result.error().code(e.getCode())\n                .message(e.getErrMsg());\n    }\n}\n```\n\n\n\n返回状态码接口的信息\n\n**BusinessException**\n\n```java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class BusinessException extends RuntimeException{\n    @ApiModelProperty(value = \"状态码\")\n    private Integer code;\n\n    @ApiModelProperty(value = \"错误信息\")\n    private String errMsg;\n}\n```\n\n# 5、统一日志处理（knife4j美化swagger2）\n\n需要knife4j依赖，\n\n在common项目的config目录下\n\n**Knife4jConfiguration**\n\n```java\n@Configuration\npublic class Knife4jConfiguration {\n\n    @Bean(value = \"defaultApi2\")\n    public Docket defaultApi2() {\n        Docket docket=new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(new ApiInfoBuilder()\n                        //.title(\"swagger-bootstrap-ui-demo RESTful APIs\")\n                        .description(\"# swagger-bootstrap-ui-demo RESTful APIs\")\n                        .termsOfServiceUrl(\"http://www.xx.com/\")\n                        .contact(\"xx@qq.com\")\n                        .version(\"1.0\")\n                        .build())\n                //分组名称\n                .groupName(\"2.X版本\")\n                .select()\n                //这里指定Controller扫描包路径\n                .apis(RequestHandlerSelectors.basePackage(\"com.xiaoliu.system.controller\"))\n                .paths(PathSelectors.any())\n                .build();\n        return docket;\n    }\n}\n```\n\n之后访问xxx/**doc.html**\n\n# 6、统一生成的日志管理\n\nLogBack\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\n<!-- 级别从高到低 OFF 、 FATAL 、 ERROR 、 WARN 、 INFO 、 DEBUG 、 TRACE 、 ALL -->\n<!-- 日志输出规则 根据当前ROOT 级别，日志输出时，级别高于root默认的级别时 会输出 -->\n<!-- 以下 每个配置的 filter 是过滤掉输出文件里面，会出现高级别文件，依然出现低级别的日志信息，通过filter 过滤只记录本级别的日志 -->\n<!-- scan 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 -->\n<!-- scanPeriod 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 -->\n<!-- debug 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 -->\n<configuration scan=\"true\" scanPeriod=\"60 seconds\" debug=\"false\">\n\n    <!-- 动态日志级别 -->\n    <jmxConfigurator/>\n\n    <!--*****************************************************************************-->\n    <!--自定义项 开始-->\n    <!--*****************************************************************************-->\n\n    <!-- 定义日志文件 输出位置 -->\n    <property name=\"log.home_dir\" value=\"E:/BliBli/xinguan/logs\"/>\n    <property name=\"log.app_name\" value=\"http-demo\"/>\n    <!-- 日志最大的历史 30天 -->\n    <property name=\"log.maxHistory\" value=\"30\"/>\n    <property name=\"log.maxSize\" value=\"5MB\"/>\n    <!-- 日志界别 -->\n    <property name=\"log.level\" value=\"info\"/>\n    <!-- 打印sql语句 需要指定dao/mapper层包的位置 -->\n    <property name=\"mapper.package\" value=\"com.xiaoge.system.mapper\"/>\n\n    <!-- 彩色日志 -->\n    <!-- 配置格式变量：CONSOLE_LOG_PATTERN 彩色日志格式 -->\n    <!-- magenta:洋红 -->\n    <!-- boldMagenta:粗红-->\n    <!-- cyan:青色 -->\n    <!-- white:白色 -->\n    <!-- magenta:洋红 -->\n    <property name=\"CONSOLE_LOG_PATTERN\"\n              value=\"%yellow(%date{yyyy-MM-dd HH:mm:ss}) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)\"/>\n\n    <!--*****************************************************************************-->\n    <!--自定义项 结束-->\n    <!--*****************************************************************************-->\n\n    <!-- ConsoleAppender 控制台输出日志 -->\n    <appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <pattern>\n                <!-- 设置日志输出格式 -->\n                ${CONSOLE_LOG_PATTERN}\n            </pattern>\n        </encoder>\n    </appender>\n\n    <!-- ERROR级别日志 -->\n    <!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 RollingFileAppender -->\n    <appender name=\"ERROR\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <!-- 过滤器，只记录WARN级别的日志 -->\n        <!-- 果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。 -->\n        <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n            <!-- 设置过滤级别 -->\n            <level>ERROR</level>\n            <!-- 用于配置符合过滤条件的操作 -->\n            <onMatch>ACCEPT</onMatch>\n            <!-- 用于配置不符合过滤条件的操作 -->\n            <onMismatch>DENY</onMismatch>\n        </filter>\n        <!-- 最常用的滚动策略，它根据时间来制定滚动策略.既负责滚动也负责触发滚动 -->\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n            <!--日志输出位置 可相对、和绝对路径 -->\n            <fileNamePattern>\n                ${log.home_dir}/error/%d{yyyy-MM-dd}/${log.app_name}-%i.log\n            </fileNamePattern>\n            <!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件,假设设置每个月滚动，且<maxHistory>是6，\n            则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除 -->\n            <maxHistory>${log.maxHistory}</maxHistory>\n            <!--日志文件最大的大小-->\n            <MaxFileSize>${log.maxSize}</MaxFileSize>\n        </rollingPolicy>\n        <encoder>\n            <pattern>\n                <!-- 设置日志输出格式 -->\n                %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n\n            </pattern>\n        </encoder>\n    </appender>\n\n\n    <!-- WARN级别日志 appender -->\n    <appender name=\"WARN\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <!-- 过滤器，只记录WARN级别的日志 -->\n        <!-- 果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。 -->\n        <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n            <!-- 设置过滤级别 -->\n            <level>WARN</level>\n            <!-- 用于配置符合过滤条件的操作 -->\n            <onMatch>ACCEPT</onMatch>\n            <!-- 用于配置不符合过滤条件的操作 -->\n            <onMismatch>DENY</onMismatch>\n        </filter>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n            <!--日志输出位置 可相对、和绝对路径 -->\n            <fileNamePattern>${log.home_dir}/warn/%d{yyyy-MM-dd}/${log.app_name}-%i.log</fileNamePattern>\n            <maxHistory>${log.maxHistory}</maxHistory>\n            <!--当天的日志大小 超过MaxFileSize时,压缩日志并保存-->\n            <MaxFileSize>${log.maxSize}</MaxFileSize>\n        </rollingPolicy>\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>\n        </encoder>\n    </appender>\n\n\n    <!-- INFO级别日志 appender -->\n    <appender name=\"INFO\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n            <level>INFO</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n            <fileNamePattern>${log.home_dir}/info/%d{yyyy-MM-dd}/${log.app_name}-%i.log</fileNamePattern>\n            <maxHistory>${log.maxHistory}</maxHistory>\n            <MaxFileSize>${log.maxSize}</MaxFileSize>\n        </rollingPolicy>\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %logger - %msg%n</pattern>\n        </encoder>\n    </appender>\n\n\n    <!-- DEBUG级别日志 appender -->\n    <appender name=\"DEBUG\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n            <level>DEBUG</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n            <fileNamePattern>${log.home_dir}/debug/%d{yyyy-MM-dd}/${log.app_name}-%i.log</fileNamePattern>\n            <maxHistory>${log.maxHistory}</maxHistory>\n            <MaxFileSize>${log.maxSize}</MaxFileSize>\n        </rollingPolicy>\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %logger - %msg%n</pattern>\n        </encoder>\n    </appender>\n\n\n    <!-- TRACE级别日志 appender -->\n    <appender name=\"TRACE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n            <level>TRACE</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n            <fileNamePattern>${log.home_dir}/trace/%d{yyyy-MM-dd}/${log.app_name}-%i.log</fileNamePattern>\n            <maxHistory>${log.maxHistory}</maxHistory>\n            <MaxFileSize>${log.maxSize}</MaxFileSize>\n        </rollingPolicy>\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %logger - %msg%n</pattern>\n        </encoder>\n    </appender>\n\n\n    <!--设置一个向上传递的appender,所有级别的日志都会输出-->\n    <appender name=\"app\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n            <fileNamePattern>${log.home_dir}/app/%d{yyyy-MM-dd}/${log.app_name}-%i.log</fileNamePattern>\n            <maxHistory>${log.maxHistory}</maxHistory>\n            <MaxFileSize>${log.maxSize}</MaxFileSize>\n        </rollingPolicy>\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %logger - %msg%n</pattern>\n        </encoder>\n    </appender>\n\n\n    <!--org.springframework.web包下的类的日志输出-->\n    <logger name=\"org.springframework.web\" additivity=\"false\" level=\"WARN\">\n        <appender-ref ref=\"WARN\"/>\n    </logger>\n    <!--dao层包下的类的日志输出-->\n    <logger name=\"${mapper.package}\" additivity=\"false\" level=\"DEBUG\">\n        <appender-ref ref=\"app\"/>\n        <appender-ref ref=\"ERROR\"/>\n        <!--打印控制台-->\n        <appender-ref ref=\"CONSOLE\"/>\n    </logger>\n\n\n    <!-- root级别   DEBUG -->\n    <root>\n        <!-- 打印debug级别日志及以上级别日志 -->\n        <level value=\"${log.level}\"/>\n        <!-- 控制台输出 -->\n        <appender-ref ref=\"CONSOLE\"/>\n        <!-- 不管什么包下的日志都输出文件 -->\n        <appender-ref ref=\"ERROR\"/>\n        <appender-ref ref=\"INFO\"/>\n        <appender-ref ref=\"WARN\"/>\n        <appender-ref ref=\"DEBUG\"/>\n        <appender-ref ref=\"TRACE\"/>\n    </root>\n\n</configuration>\n\n```\n\n\n\n# 7、后台数据分页查询\n\n需要mybatis-plus的**分页插件**\n\n在common项目下的config目录下\n\n```java\n@Configuration\npublic class MybatisPlusConfig {\n\n    /**\n     * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题(该属性会在旧插件移除后一同移除)\n     */\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor() {\n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.H2));\n        return interceptor;\n    }\n\n    @Bean\n    public ConfigurationCustomizer configurationCustomizer() {\n        return configuration -> configuration.setUseDeprecatedExecutor(false);\n    }\n}\n```\n\n\n\n分页查询的controller\n\n```java\n@GetMapping(\"/findUserList\")\n    public Result findUserList(@RequestParam(defaultValue = \"1\")Integer current,\n                               @RequestParam(defaultValue = \"7\")Integer size){\n//        对用户分页，泛型中注入的是用户实体类\n        Page<User> page = new Page<>(current,size);\n        Page<User> userPage = userService.page(page);\n        long total = userPage.getTotal();\n        List<User> records = userPage.getRecords();\n        return Result.ok().data(\"total\",total).data(\"records\",records);\n    };\n```\n\n# 8、使用axios请求后台接口\n\n引入axios\n\n`npm install axios`\n\n\n\n在前端项目中新建一个utils包\n\nrequest.js\n\n```js\nimport axios from \'axios\'\n\nconst instance = axios.create({\n    baseURL: \'http://localhost:8081\',\n    timeout: 3000,\n  });\n\n  export default instance\n```\n\n新建api包\n\nusers.js\n\n```js\nimport request from \'../utils/request\'\n\n// 后面每次请求都是携带token的\nexport const findUserList =()=>{\n    return request({\n        url: \"/user/findUserList\",\n        method: \'get\',\n\n    })\n}   \n```\n\n\n\n在Uses.vue组件中\n\n添加获取用户列表的方法,并在控制台打印\n\n```vue\nasync getUserList(){\n       const {data}  = await findUserList()\n       console.log(data);\n      }\n```\n\n钩子函数加载\n\n```vue\ncreated(){\n    this.getUserList();\n  },\n```\n\n\n\n# 9、跨域问题 Access-Control-Allow-Origin\n\n![image-20220507234028635](image-20220507234028635.png)\n\n\n\n## 9.1、nginx反向代理解决跨域\n\n## 9.2、jsonp解决跨域（axios不支持）\n\n## 9.3、springboot的@CrossOrign\n\n## 9.4、配置webmvcconfigure解决跨域\n\n```java\n@Configuration\npublic class CrosConfig implements WebMvcConfigurer {\n    /**\n     *\n     * @param registry\n     */\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/**\").allowedOrigins(\"*\")\n                .allowedMethods(\"GET\",\"POST\",\"PUT\",\"OPTIONS\",\"HEAD\")\n                .allowCredentials(true)\n                .maxAge(3600)\n                .allowedHeaders(\"*\");\n    }\n}\n```\n\n\n\n# 10、用户数据绑定及分页展示\n\n\n\n# 11、mybatisplus实现多表联查（用户部门）\n\n\n\n# 12、编写添加用户界面\n\n\n\n# 13、实现头像上传\n\n阿里云的OSS 需要joda-time依赖\n\n```java\n           //获取上传的文件流\n            InputStream inputStream = file.getInputStream();\n//            保证文件名不相同 uuid redis分布式ID 雪花算法 方便区分 文件格式 yyyy/MM/dd+uuid\n//              构建日期文件夹的路径 avatar/2022/5/14 文件名\n            String datePath = new DateTime().toString(\"yyyy/MM/dd\");\n\n//            获取文件的名称\n            String original = file.getOriginalFilename();\n\n//            获取uuid\n            String fileName = UUID.randomUUID().toString().replaceAll(\"-\", \"/\");\n\n//            获得文件上传的扩展名 .jpg\n            String fileType = original.substring(original.lastIndexOf(\".\"));\n\n//            拼接文件名称 cfbf6d34d3e4465386f0e33d4595d52b.jpg\n            String newName = fileName + fileType;\n\n//            生成文件夹 avatar/2022/5/14 + cfbf6d34d3e4465386f0e33d4595d52b.jpg\n            fileName = datePath + \"/\" + newName;\n//            上传文件\n            ossClient.putObject(bucketName, fileName,inputStream);\n\n\n            //默认十年不过期\n            Date expiration = new Date(System.currentTimeMillis() + 3600L * 1000 * 24 * 365 * 10);\n\n            //bucket名称  文件名   过期时间\n            uploadUrl = ossClient.generatePresignedUrl(bucketName, fileName, expiration).toString();\n\n            //获取url地址\n            //uploadUrl = \"https://\" + bucketName + \".\" + endPoint + \"/\" + fileName;\n        return uploadUrl.substring(0, uploadUrl.indexOf(\"?\"));\n        不能直接返回uploadUrl 需要去除？后面的签名信息\n            \n            /**\n     * Description: 判断OSS服务文件上传时文件的contentType\n     *\n     * @param FilenameExtension 文件后缀\n     * @return String\n     */\n    public static String getcontentType(String FilenameExtension) {\n        if (FilenameExtension.equalsIgnoreCase(\".bmp\")) {\n            return \"image/bmp\";\n        }\n        if (FilenameExtension.equalsIgnoreCase(\".gif\")) {\n            return \"image/gif\";\n        }\n        if (FilenameExtension.equalsIgnoreCase(\".jpeg\") ||\n                FilenameExtension.equalsIgnoreCase(\".jpg\") ||\n                FilenameExtension.equalsIgnoreCase(\".png\")) {\n            return \"image/jpg\";\n        }\n        if (FilenameExtension.equalsIgnoreCase(\".html\")) {\n            return \"text/html\";\n        }\n        if (FilenameExtension.equalsIgnoreCase(\".txt\")) {\n            return \"text/plain\";\n        }\n        if (FilenameExtension.equalsIgnoreCase(\".vsd\")) {\n            return \"application/vnd.visio\";\n        }\n        if (FilenameExtension.equalsIgnoreCase(\".pptx\") ||\n                FilenameExtension.equalsIgnoreCase(\".ppt\")) {\n            return \"application/vnd.ms-powerpoint\";\n        }\n        if (FilenameExtension.equalsIgnoreCase(\".docx\") ||\n                FilenameExtension.equalsIgnoreCase(\".doc\")) {\n            return \"application/msword\";\n        }\n        if (FilenameExtension.equalsIgnoreCase(\".xml\")) {\n            return \"text/xml\";\n        }\n        return \"image/jpg\";\n    }\n```\n', 0, '2022-09-06 00:04:47', '2022-10-21 20:01:00', 0, 1, 8, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/06/0df103b9ca68477f803cf63b15f1559a.jpg', 7);
INSERT INTO `t_blog` VALUES (225, ' 项目-前端', '搭好前端脚手架', '# 搭好前端脚手架\n\nrouter,vuex,elementpuls,\n\n# 配置全局样式\n\ncss文件下\n\n```css\n/* 全局样式表 */\nhtml,body，#app{\n    height: 100%;\n    margin: 0;\n    padding: 0;\n}\n```\n\nmain.js下\n\n```js\nimport \'@/assets/css/global.css\'\n```\n\n\n\n# 1、登录页面\n\n使用less\n\n**安装**\n\n```\nnpm install --save-dev less-loader less\n```\n\n```js\n<style lang=\"less\"></style>\n```\n\n\n\nvue3使用图标需要全局注册组件\n\n```bash\nnpm install @element-plus/icons-vue\n```\n\nmain.js中\n\n```js\nimport * as ElementPlusIconsVue from \'@element-plus/icons-vue\'\nfor (const [key, component] of Object.entries(ElementPlusIconsVue)) {\n  app.component(key, component)\n}\n```\n\n直接引用 \n\n\n\n**使用icon的方法**\n\n```js\nimport { Avatar, Lock } from \"@element-plus/icons-vue\";\n```\n\n```js\nsetup(){\n  return {\n     Avatar,\n     Lock\n   }\n  }\n```\n\n输入框中引用\n\n```js\n账号 prefix-icon=\"Avatar\"\n密码 prefix-icon=\"Lock\"\n```\n\n\n\n**login.vue登录页面**\n\n```vue\n<template>\n  <!-- 登录容器 -->\n  <div class=\"login_container\">\n    <!-- 登录区域 -->\n    <div class=\"login_box\">\n      <!-- 头像 -->\n      <div class=\"avatar_box\">\n        <img src=\"@/assets/src.jpeg\" />\n      </div>\n      <!-- 表单 -->\n      <el-form\n        :model=\"loginForm\"\n        :rules=\"loginrules\"\n        ref=\"loginForm\"\n        label-width=\"0px\"\n        class=\"login_form\"\n      >\n        <el-form-item prop=\"username\">\n          <el-input\n            v-model=\"loginForm.username\"\n            prefix-icon=\"Avatar\"\n          ></el-input>\n        </el-form-item>\n        <el-form-item prop=\"password\">\n          <el-input\n            v-model=\"loginForm.password\"\n            prefix-icon=\"Lock\"\n            type=\"password\"\n          ></el-input>\n        </el-form-item>\n        <el-form-item prop=\"verifyCode\">\n          <el-input\n            v-model=\"loginForm.verifyCode\"\n            prefix-icon=\"Iphone\"\n            class=\"verify_code\"\n          ></el-input>\n          <img src=\"@/assets/msFvb6.gif\" class=\"verify_img\" />\n        </el-form-item>\n        <el-form-item class=\"login_btn\">\n          <el-button type=\"primary\" @click=\"submitForm(\'loginForm\')\"\n            >登录</el-button\n          >\n          <el-button @click=\"resetForm(\'loginForm\')\">重置</el-button>\n        </el-form-item>\n      </el-form>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { Avatar, Lock, Iphone } from \"@element-plus/icons-vue\";\nexport default {\n  setup() {\n    return {\n      Avatar,\n      Lock,\n      Iphone,\n    };\n  },\n  data() {\n    return {\n      loginForm: {\n        username: \"\",\n        password: \"\",\n        verifyCode: \"\",\n      },\n      loginrules: {\n        username: [\n          { required: true, message: \"请输入账号\", trigger: \"blur\" },\n          {\n            min: 3,\n            max: 16,\n            message: \"长度在 3 到 16 个字符\",\n            trigger: \"blur\",\n          },\n        ],\n        password: [\n          { required: true, message: \"请输入密码\", trigger: \"blur\" },\n          {\n            min: 3,\n            max: 16,\n            message: \"长度在 3 到 16  个字符\",\n            trigger: \"blur\",\n          },\n        ],\n        verifyCode: [\n          { required: true, message: \"请输入验证码\", trigger: \"blur\" },\n          {\n            min: 3,\n            max: 16,\n            trigger: \"blur\",\n          },\n        ],\n      },\n    };\n  },\n  methods: {\n    submitForm(formName) {\n      this.$refs[formName].validate((valid) => {\n        if (valid) {\n          alert(\"submit!\");\n        } else {\n          console.log(\"error submit!!\");\n          return false;\n        }\n      });\n    },\n    resetForm(formName) {\n      this.$refs[formName].resetFields();\n    },\n  },\n};\n</script>\n<style lang=\'less\' scoped>\n.login_container {\n  height: 100%;\n  background-color: aquamarine;\n}\n.login_box {\n  width: 450px;\n  height: 380px;\n  background-color: #ffffff;\n  border-radius: 3px;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  .avatar_box {\n    width: 130px;\n    height: 130px;\n    border: 1px solid #eeeeee;\n    border-radius: 50%;\n    padding: 10px;\n    box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);\n    margin: -65px auto;\n    background: #ffffff;\n    img {\n      width: 100%;\n      height: 100%;\n      border-radius: 50%;\n      background-color: #eeeeee;\n    }\n  }\n  .login_form {\n    position: absolute;\n    bottom: 0px;\n    width: 100%;\n  }\n  .login_btn {\n    display: flex;\n    justify-content: flex-end;\n  }\n  .verify_code {\n    width: 60%;\n  }\n}\n</style>\n```\n\n\n\n# 2、Main页面\n\n鼠标放上图片拉下菜单\n\n```css\n.el-dropdown-menu,img{\n      height: 60px;\n      width: 60px;\n      border-radius: 50%;\n\n    }\n```\n\n```css\n<el-dropdown>\n          <!-- 右边头像 -->\n          <img src=\"@/assets/src.jpeg\" />\n          <!-- 下拉菜单 -->\n          <template #dropdown>\n            <el-dropdown-menu>\n              <el-dropdown-item icon=\"HomeFilled\">系统主页</el-dropdown-item>\n              <el-dropdown-item icon=\"Warning\">退出登录</el-dropdown-item>\n            </el-dropdown-menu>\n          </template>\n        </el-dropdown>\n```\n\n\n\n**注意：**去除侧边栏展开多出的边缘，\n\n```css\n.el-menu-vertical-demo{\n border-right: none;\n}\n```\n\n\n\n**Main.vue**页面\n\n```vue\n<template>\n  <el-container class=\"main_container\">\n    <el-header>\n      <div class=\"left_box\">\n        <!-- 左边头像 -->\n        <img src=\"@/assets/src.jpeg\" />\n        <span>系统</span>\n      </div>\n\n      <div class=\"right_box\">\n        <el-dropdown>\n          <!-- 右边头像 -->\n          <img src=\"@/assets/src.jpeg\" />\n          <!-- 下拉菜单 -->\n          <template #dropdown>\n            <el-dropdown-menu>\n              <el-dropdown-item icon=\"HomeFilled\">系统主页</el-dropdown-item>\n              <el-dropdown-item icon=\"Warning\">退出登录</el-dropdown-item>\n            </el-dropdown-menu>\n          </template>\n        </el-dropdown>\n      </div>\n    </el-header>\n    <el-container>\n      <!-- 侧边栏 -->\n      <el-aside :width=\"iscollapse?\'60px\':\'200px\'\">\n        <!-- 展开收起 -->\n      <div class=\"toggle_box\" @click=\"toggleiscollapse\">|||</div>\n      <el-menu\n        active-text-color=\"#ffd04b\"\n        background-color=\"#001529\"\n        class=\"el-menu-vertical-demo\"\n        :collapse=\"iscollapse\"\n        :collapse-transition=\"iscollapsetransition\"\n        :router=\"true\"\n        default-active=\"2\"\n        text-color=\"#fff\"\n        @open=\"handleOpen\"\n        @close=\"handleClose\"\n      >\n        <MenuTree :menuList=\"this.MenuList\"></MenuTree>\n      </el-menu>\n\n      </el-aside>\n      <el-main>\n        <router-view/>\n      </el-main>\n    </el-container>\n  </el-container>\n</template>\n\n<script>\nimport MenuTree from \'@/components/MenuTree.vue\'\nexport default {\n  name: \"Main\",\n  data() {\n    return {\n      iscollapse: false,\n      iscollapsetransition: false,\n      MenuList: [\n        {\n            \"id\": 1,\n            \"parentId\": 0,\n            \"menuName\": \"系统管理\",\n            \"url\": \"\",\n            \"icon\": \"el-icon-setting\",\n            \"orderNum\": 1,\n            \"open\": 1,\n            \"disabled\": false,\n            \"perms\": null,\n            \"type\": 0,\n            \"children\": [\n              {\n                \"id\": 253,\n                \"parentId\": 1,\n                \"menuName\": \"欢迎页面\",\n                \"url\": \"/welcome\",\n                \"icon\": \"el-icon-star-off\",\n                \"orderNum\": 1,\n                \"open\": 0,\n                \"disabled\": false,\n                \"perms\": \"welcome:view\",\n                \"type\": 0,\n                \"children\": []\n              },\n              {\n                \"id\": 226,\n                \"parentId\": 1,\n                \"menuName\": \"用户管理\",\n                \"url\": \"/users\",\n                \"icon\": \"el-icon-user\",\n                \"orderNum\": 2,\n                \"open\": 0,\n                \"disabled\": false,\n                \"perms\": \"users\",\n                \"type\": 0,\n                \"children\": []\n              },\n              {\n                \"id\": 321,\n                \"parentId\": 1,\n                \"menuName\": \"附件管理\",\n                \"url\": \"/attachments\",\n                \"icon\": \"el-icon-picture-outline\",\n                \"orderNum\": 2,\n                \"open\": 1,\n                \"disabled\": false,\n                \"perms\": \"\",\n                \"type\": 0,\n                \"children\": []\n              },\n              {\n                \"id\": 4,\n                \"parentId\": 1,\n                \"menuName\": \"菜单权限\",\n                \"url\": \"/menus\",\n                \"icon\": \"el-icon-help\",\n                \"orderNum\": 3,\n                \"open\": 0,\n                \"disabled\": false,\n                \"perms\": null,\n                \"type\": 0,\n                \"children\": []\n              },\n              {\n                \"id\": 235,\n                \"parentId\": 1,\n                \"menuName\": \"角色管理\",\n                \"url\": \"/roles\",\n                \"icon\": \"el-icon-postcard\",\n                \"orderNum\": 3,\n                \"open\": 0,\n                \"disabled\": false,\n                \"perms\": \"\",\n                \"type\": 0,\n                \"children\": []\n              },\n              {\n                \"id\": 261,\n                \"parentId\": 1,\n                \"menuName\": \"部门管理\",\n                \"url\": \"/departments\",\n                \"icon\": \"el-icon-s-home\",\n                \"orderNum\": 3,\n                \"open\": 0,\n                \"disabled\": false,\n                \"perms\": \"\",\n                \"type\": 0,\n                \"children\": []\n              },\n              {\n                \"id\": 319,\n                \"parentId\": 1,\n                \"menuName\": \"公告管理\",\n                \"url\": \"/notices\",\n                \"icon\": \"el-icon-s-flag\",\n                \"orderNum\": 4,\n                \"open\": 0,\n                \"disabled\": true,\n                \"perms\": \"\",\n                \"type\": 0,\n                \"children\": []\n              }\n            ]\n          },\n         \n          {\n            \"id\": 303,\n            \"parentId\": 0,\n            \"menuName\": \"健康报备\",\n            \"url\": \"\",\n            \"icon\": \"el-icon-platform-eleme\",\n            \"orderNum\": 3,\n            \"open\": 0,\n            \"disabled\": false,\n            \"perms\": \"\",\n            \"type\": 0,\n            \"children\": [\n              {\n                \"id\": 273,\n                \"parentId\": 303,\n                \"menuName\": \"全国疫情\",\n                \"url\": \"/map\",\n                \"icon\": \"el-icon-s-opportunity\",\n                \"orderNum\": 1,\n                \"open\": 1,\n                \"disabled\": false,\n                \"perms\": \"map:view\",\n                \"type\": 0,\n                \"children\": []\n              },\n              {\n                \"id\": 304,\n                \"parentId\": 303,\n                \"menuName\": \"健康打卡\",\n                \"url\": \"/health\",\n                \"icon\": \"el-icon-s-cooperation\",\n                \"orderNum\": 1,\n                \"open\": 0,\n                \"disabled\": false,\n                \"perms\": \"\",\n                \"type\": 0,\n                \"children\": []\n              },\n              {\n                \"id\": 305,\n                \"parentId\": 303,\n                \"menuName\": \"查看情况\",\n                \"url\": null,\n                \"icon\": \"el-icon-c-scale-to-original\",\n                \"orderNum\": 2,\n                \"open\": 1,\n                \"disabled\": false,\n                \"perms\": null,\n                \"type\": 0,\n                \"children\": []\n              },\n              {\n                \"id\": 272,\n                \"parentId\": 303,\n                \"menuName\": \"疫情辟谣\",\n                \"url\": \"/rumors\",\n                \"icon\": \"el-icon-help\",\n                \"orderNum\": 5,\n                \"open\": 0,\n                \"disabled\": false,\n                \"perms\": null,\n                \"type\": 0,\n                \"children\": []\n              }\n            ]\n          },\n          {\n            \"id\": 295,\n            \"parentId\": 0,\n            \"menuName\": \"其他管理\",\n            \"url\": \"\",\n            \"icon\": \"el-icon-s-marketing\",\n            \"orderNum\": 5,\n            \"open\": 0,\n            \"disabled\": false,\n            \"perms\": \"\",\n            \"type\": 0,\n            \"children\": [\n              {\n                \"id\": 297,\n                \"parentId\": 295,\n                \"menuName\": \"监控管理\",\n                \"url\": \"\",\n                \"icon\": \"el-icon-warning\",\n                \"orderNum\": 1,\n                \"open\": 0,\n                \"disabled\": false,\n                \"perms\": \"\",\n                \"type\": 0,\n                \"children\": [\n                  {\n                    \"id\": 298,\n                    \"parentId\": 297,\n                    \"menuName\": \"SQL监控\",\n                    \"url\": \"/druid\",\n                    \"icon\": \"el-icon-view\",\n                    \"orderNum\": 1,\n                    \"open\": 0,\n                    \"disabled\": false,\n                    \"perms\": null,\n                    \"type\": 0,\n                    \"children\": []\n                  }\n                ]\n              },\n              {\n                \"id\": 341,\n                \"parentId\": 295,\n                \"menuName\": \"个人博客\",\n                \"url\": \"/blog\",\n                \"icon\": \"el-icon-view\",\n                \"orderNum\": 1,\n                \"open\": 0,\n                \"disabled\": false,\n                \"perms\": \"\",\n                \"type\": 0,\n                \"children\": []\n              },\n              {\n                \"id\": 296,\n                \"parentId\": 295,\n                \"menuName\": \"swagger文档\",\n                \"url\": \"/swagger\",\n                \"icon\": \"el-icon-document\",\n                \"orderNum\": 2,\n                \"open\": 0,\n                \"disabled\": false,\n                \"perms\": null,\n                \"type\": 0,\n                \"children\": []\n              },\n              {\n                \"id\": 318,\n                \"parentId\": 295,\n                \"menuName\": \"图标管理\",\n                \"url\": \"/icons\",\n                \"icon\": \"el-icon-star-off\",\n                \"orderNum\": 2,\n                \"open\": 1,\n                \"disabled\": false,\n                \"perms\": \"\",\n                \"type\": 0,\n                \"children\": []\n              }\n            ]\n          },\n          {\n            \"id\": 5,\n            \"parentId\": 0,\n            \"menuName\": \"日志管理\",\n            \"url\": \"/logs\",\n            \"icon\": \"el-icon-camera\",\n            \"orderNum\": 6,\n            \"open\": 0,\n            \"disabled\": false,\n            \"perms\": null,\n            \"type\": 0,\n            \"children\": [\n              {\n                \"id\": 271,\n                \"parentId\": 5,\n                \"menuName\": \"登入日志\",\n                \"url\": \"/loginLog\",\n                \"icon\": \"el-icon-date\",\n                \"orderNum\": 1,\n                \"open\": 0,\n                \"disabled\": false,\n                \"perms\": \"login:log\",\n                \"type\": 0,\n                \"children\": []\n              },\n              {\n                \"id\": 307,\n                \"parentId\": 5,\n                \"menuName\": \"操作日志\",\n                \"url\": \"/logs\",\n                \"icon\": \"el-icon-edit\",\n                \"orderNum\": 1,\n                \"open\": 1,\n                \"disabled\": false,\n                \"perms\": \"\",\n                \"type\": 0,\n                \"children\": []\n              }\n            ]\n          }\n      ]\n    };\n  },\n  methods: {\n    toggleiscollapse() {\n      this.iscollapse = !this.iscollapse;\n    },\n  },\n  components: {\n    MenuTree,\n},\n};\n</script>\n<style  lang=\'less\' scoped>\n// 头部布局\n.el-header {\n  background-color: #001529;\n  display: flex;\n  justify-content: space-between;\n  padding-left: 0;\n  color: #ffffff;\n  align-items: center;\n  font-size: 20px;\n  // 左边头像样式\n  .left_box {\n    display: flex;\n    align-items: center; //文本居中\n\n    img {\n      width: 60px;\n      height: 60px;\n      margin: 0px 0px 10px 15px; //边缘\n    }\n    // 文本\n    span {\n      margin-left: 15px;\n    }\n  }\n  // 右边头像样式\n  .right_box {\n    .el-dropdown-menu,\n    img {\n      height: 60px;\n      width: 60px;\n      border-radius: 50%;\n      background-size: contain; //容器包裹头像\n    }\n  }\n}\n// 侧边栏\n.el-aside {\n  background-color: #001529;\n\n  .el-menu-vertical-demo{\n    border-right: none;\n  }\n  // 收起功能样式\n  .toggle_box {\n    background-color: #001529;\n    color: #FFFFFF;\n    text-align: center;\n    cursor: pointer;\n    font-size: 15px;\n    font-weight: bold;\n    line-height: 24px;\n  }\n}\n// 主体布局\n.el-main {\n  background-color: #e9eef3;\n}\n\n// 整个容器高度\n.main_container {\n  height: 100%;\n}\n</style>\n```\n\n\n\n## **2.1、MenuTree.vue组件**\n\n```vue\n<template >\n  <div>\n    <template v-for=\"item in this.menuList\">\n      <el-sub-menu\n        :disabled=\"item.disabled\"\n        :index=\"item.id + \'\'\"\n        :key=\"item.id + \'\'\"\n        v-if=\"item.children.length > 0\"\n      >\n        <template #title>\n          <el-icon class=\"is-loading\">\n    <loading />\n  </el-icon>\n          <span>{{ item.menuName }}</span>\n        </template>\n        <MenuTree :menuList=\"item.children\"></MenuTree>\n      </el-sub-menu>\n\n      <el-menu-item v-else :disabled=\"item.disabled\" :index=\"item.url+\'\'\" :router=\"true\" :key=\"item.id+\'\'\">\n        <el-icon class=\"is-loading\">\n    <loading />\n  </el-icon>\n        <span>{{ item.menuName }}</span>\n      </el-menu-item>\n    </template>\n  </div>\n</template>\n\n\n<script>\nexport default {\n  name: \"MenuTree\",\n  props: [\"menuList\"],\n};\n</script>\n<style  >\n/* 溢出效果解决 */\n  .el-menu--collapse span,\n  .el-menu--collapse i.el-sub-menu__icon-arrow{\n    height: 0;\n    width: 0;\n    overflow: hidden;\n    visibility: hidden;\n    display: inline-block;\n  }\n\n</style>\n```\n\n\n\n# 3、用户管理界面\n\n\n\n# 4、用户数据绑定及分页展示\n\n# 5、前端绑定部门信息\n\n# 6、用户列表查询\n', 0, '2022-09-06 00:05:18', '2022-10-21 20:01:00', 0, 119, 11, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/06/f93deb981fab4796b8d2ce8e39355f3f.jpg', 7);
INSERT INTO `t_blog` VALUES (226, 'linux', 'linux初学', '#Linux\n在/etc/profile配置环境变量\n\n```bash\nexport JAVA_HOME=/usr/local/java/jdk1.8.0_333\nexport JRE_HOME=${JAVA_HOME}/jre\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib\nexport PATH=${JAVA_HOME}/bin:$PATH\n```\n\n\n#使环境变量生效\n```bash\nsource /etc/profile\n```\n\n\n#验证\n```bash\njava -version\n```\n\n后台启动java\n```bash\nnohup java -jar xxx.jar &\n```\n\n关闭进程\n```bash\nkill -9 进程号 \n```\n\n查看进程号\n```bash\nps -ef | grep java\n```\n\n创建文件\n```bash\ntouch xxx\n```\n\n创建目录\n```bash\nmkdir xxx\n```\n\n软硬连接\n#软连接\n```bash\nln -sf target source #强制执行\n```\n\n#硬连接\n```bash\nln target source\n```\n\n查找\n```bash\nfind -name *xxx* #查找xxx名字的文件\nfind /path -xx xxx #在/path目录下查找xxx名字的文件\n```\n\n输出重定向\n```bash\necho xxx | grep xxx #grep为管道命令 连接 |前面命令输出的内容\n```\n\n查看\n```bash\ncat\ntop #查看硬件占用情况\n```\n# Vim\n```bash\nvim编辑\n1.vim撤销操作\n将vim调整到命令模式\n键入小写u\n2.恢复撤销操作\n将vim调整到命令模式\n键入Ctrl + r\n3.出现vim意外退出时\nls -a显示所有文件\nrm -f 删除swap文件\n4.复制该文件中的第2、3行内容，并将所复制内容粘贴在最后\n•  按“ESC”从插入模式退回到普通模式；\n•  将光标移动到第2行，输入快捷命令“2yy”，表示复制从当前光标所在行开始的2行；\n•  然后将光标移动到第3行，输入快捷命令“p”，表示将刚才复制的内容粘贴在当前行后面\n5. 删除第1行内容，退出但不存盘，然后重新使用vim打开vimfile文件\n•  在普通模式下，输入快捷移动命令“gg”，将光标移动到第一行，然后输入快捷命令“dd”表示删除光标所在行；\n•  按“：”进入命令模式，输入q!命令，表示强制退出vim编辑，忽略所做的修改，即不存盘退出；\n\n6.将文件另存为/home/vimbak，删除第1行后所有行，保存文件并退出，比较vimfile和vimbak文件内容的不同\n• 输入“：”进入到命令模式，输入命令w /home/vimbak，即将当前内容写入到文件/home/vimbak中，该命令可以用于对当前内容做备份；\n• 在普通模式下将光标移动到第2行，输入快捷命令“4dd”表示删除从当前行开始的4行；\n• 输入“：”进入命令模式，输入命令wq，存盘退出。\n\n7.删除、复制\n删除：\n全部删除：按esc后，然后dG\n选中内容后删除：d  删除选中内容 \n删除光标指向的行：dd\n复制：\n复制多行 方法1：\n（1）将光标移动到要复制的文本开始的地方，按v进入可视模式。\n（2）将光标移动到要复制的文本的结束的地方，按y复制。此时vim会自动将光标定位到选中文本的开始的地方，并退出可视模式。\n（4）我移动光标到文本结束的地方，按p粘贴\n\n复制多行 方法2：\n:9，15 copy 16 表示复制9～15行内容，并将复制好的内容放置到16行\n\n选中内容后复制：y  复制选中内容到0号寄存器 \n+y  复制选中内容到＋寄存器，也就是系统的剪贴板，供其他程序用\n\n8。不保存退出\n：q!\n```\n\n# Linux创建脚本步骤\n```bash\n第一步：创建脚本\ntouch hello.sh\n第二步：编辑脚本\nvi hello.sh\n输入：第一行不变 后几行根据需要编写\n#!/bin/bash\necho “hello 脚本”\n第三步：配置环境变量\npwd查看 将目录所在的配置到PATH:后面\nexport PATH=$PATH: /XX/XX/XX\n第四步：修改脚本权限\nchmod 755 hello.sh\n第五步：执行脚本\nhell0.sh\n或者./hello.sh(有权限的情况)\n或者 sh hello.sh\n\n修复环境变量PATH的方法\n修复PATH变量的方法。修复PATH变量其实很简单，就是重新给PATH变量赋值就可以了。至于PATH的默认值可以从其他的服务器上复制过来。\n使用\"echo $PATH\"命令就可以查看当前服务器的PATH变量值，在正常的服务器上运行命令并复制输出的结果，然后用\"export PATH\"命令重新给PATH命令赋值就可以了。命令如下：\n\"export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\"\n```\n\n\n# 用户\n```bash\n1、用户创建及删除\n一、useradd -m +用户名，将在/home目录下创建同名文件夹\nuseradd -m roberta\n二、利用（ passwd + 用户名）为指定的用户名设置密码。\npasswd roberta\n三、登陆指定用户\nsu roberta\n四、删除用户，命令：userdel 用户名。若想将它在系统上的文件也删除掉，使用命令：userdel -r 用户名\nuserdel -r roberta\n```\n\n# 变量\n```bash\n创建变量\nmyVar=\"xxx\"\n#显示变量\necho $myVar\n如果变量的值中包含了空格、制表符和换行符号，那么变量的值要用\"(双引号)或\'(单引号)括起来。\nmyVar=\' we \'\necho $myVar\n\n使用${变量名:开始位置:长度}可以获得变量中指定的子字符串。\n\n删除Shell变量\nunset myVar\n变量值的条件替换\n${变量名-默认值}：当变量未定义时，返回默认值。\n echo ${myVar-\"变量未定义\"}\n 变量未定义\n \n ${变量名:-默认值}：当变量未定义或为空字符串时，使用默认值。\n \n ${变量名+默认值}：当变量已赋值(包含空字符串)时，返回默认值。\n \n ${变量名:+默认值}：当变量已赋值非空值时，返回默认值。\n \n ${变量名=默认值}：当变量未定义时，返回并设置变量为默认值。\n获取当前时间\ndate \"+%Y-%m-%d_%H:%M:%S\"\nlinux$后边括号表示\n小括号里面是linux命令\n\n比如   cat $(pwd) > aaa 等价于 cat `pwd` > aaa  \n\n$()：这个小括号里放的是命令，和``反引号作用一样，执行这个命令\n\n${}：这里面放的是变量，用来引用的\n\n$( )中放的是命令，相当于` `，例如todaydate=$(date +%Y%m%d) 意思是执行date命令，返回执行结果给变量todaydate，也可以写为todaydate=`date +%Y%m%d`；\n\n${ }中放的是变量，例如echo ${PATH}取PATH变量的值并打印，也可以不加括号比如$PATH。\n\n```\n\n# linux中，&和&&,|和||\n在linux中，&和&&,|和||介绍如下：\n&  表示任务在后台执行，如要在后台运行redis-server,则有  redis-server &\n&& 表示前一条命令执行成功时，才执行后一条命令 ，如 echo \'1‘ && echo \'2\'    \n| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo \'yes\' | wc -l\n|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo \"fail\"\n防火墙\n启动\n```bash\nsystemctl start firewalld\n```\n\n放行端口\n例如放行3306端口\n```bash\nfirewall-cmd --zone=public --add-port=3306/tcp --permanent\n```\n\n查看端口\n```bash\nfirewall-cmd --list-all\n```\n\n# 磁盘管理\n```bash\ndf （列出文件系统整体的磁盘使用量）du（检查磁盘空间使用量）\ndf -h #显示M\n```\n\n', 0, '2022-09-06 00:28:58', '2022-10-21 20:01:00', 0, 120, 6, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/06/7998e485e3824e6bac77d32a92c4a37f.jpg', 7);
INSERT INTO `t_blog` VALUES (227, 'Hadoop学习', '2022年9月6日(第一节课hadoop)', '\n\n## 三次信息化浪潮\n\n第三次信息化浪潮涌动，大数据时代全面开启。人类社会信息科技的发展为大数据时代的到来提供了技术支撑，而数据产生方式的变革是促进大数据时代到来至关重要的因素。\n\n### 1 第三次信息化浪潮\n\n 根据IBM前首席执行官郭士纳的观点，IT领域每隔15年就会迎来一次重大变革（见表1-1）。1980年前后，个人计算机（PC）开始普及，使得计算机走入企业和千家万户，大大提高了社会生产力，也使人类迎来了第一次信息化浪潮，Intel、IBM、苹果、微软、联想等企业是这个时期的标志。随后，在1995年前后，人类开始全面进入互联网时代，互联网的普及把世界变成“地球村”，每个人都可以自由徜徉于信息的海洋，由此，人类迎来了第二次信息化浪潮，这个时期也缔造了雅虎、谷歌、阿里巴巴、百度等互联网巨头。时隔15年，在2010年前后，云计算、大数据、物联网的快速发展，拉开了第三次信息化浪潮的大幕，大数据时代已经到来，也必将涌现出一批新的市场标杆企业。\n\n​              表1-1　三次信息化浪潮![img](https://p.ananas.chaoxing.com/star3/origin/03bcf8102bed601a8048402ac1bacd1d.png)\n\n**1、 信息科技为大数据时代提供技术支撑**\n\n 信息科技需要解决信息存储、信息传输和信息处理3个核心问题，人类社会在信息科技领域的不断进步，为大数据时代的到来提供了技术支撑。\n\n**（1）存储设备容量不断增加**\n\n数据被存储在磁盘、磁带、光盘、闪存等各种类型的存储介质中，随着科学技术的不断进步，存储设备的制造工艺不断升级，容量大幅增加，速度不断提升，价格却在不断下降（见图1-1）。\n\n![img](https://p.ananas.chaoxing.com/star3/origin/e142c6b02b273b54e7ea5a75eabad044.png)\n\n早期的存储设备容量小、价格高、体积大，例如，IBM在1956年生产的一个早期的商业硬盘，容量只有5MB，不仅价格昂贵，而且体积有一个冰箱那么大。相反，今天容量为1TB的硬盘，大小只有3.5英寸（约8.89cm），读写速度达到200MB/s，价格仅为400元左右。廉价、高性能的硬盘存储设备，不仅提供了海量的存储空间，同时大大降低了数据存储成本。\n\n与此同时，以闪存为代表的新型存储介质也开始得到大规模的普及和应用。闪存是一种新兴的半导体存储器，从1989年诞生第一款闪存产品开始，闪存技术不断获得新的突破，并逐渐在计算机存储产品市场中确立了自己的重要地位。闪存是一种非易失性存储器，即使发生断电也不会丢失数据；因此，可以作为永久性存储设备，它具有体积小、质量轻、能耗低、抗振性好等优良特性。\n\n 闪存芯片可以被封装制作成SD卡、U盘和固态盘等各种存储产品，SD卡和U盘主要用于个人数据存储，固态盘则越来越多地应用于企业级数据存储。一个 32GB 的 SD 卡，体积只有24 mm×32 mm×2.1 mm，质量只有0.5g。以前7 200 r/min的硬盘，一秒钟读写次数只有100 IOPS （Input/Output Operations Per Second），传输速率只有50 MB/s，而现在基于闪存的固态盘，每秒钟读写次数有几万甚至更高的IOPS，访问延迟只有几十微秒，允许我们以更快的速度读写数据。\n\n总体而言，数据量和存储设备容量二者之间是相辅相成、互相促进的。一方面，随着数据的不断产生，需要存储的数据量不断增加，对存储设备的容量提出了更高的要求，促使存储设备生产商制造更大容量的产品满足市场需求；另一方面，更大容量的存储设备进一步加快了数据量增长的速度，在存储设备价格高企的年代，由于考虑到成本问题，一些不必要或当前不能明显体现价值的数据往往会被丢弃。但是，随着单位存储空间价格的不断降低，人们开始倾向于把更多的数据保存起来，以期在未来某个时刻可以用更先进的数据分析工具从中挖掘价值。\n\n**（2）CPU处理能力大幅提升**\n\nCPU处理速度的不断提升也是促使数据量不断增加的重要因素。性能不断提升的CPU，大大提高了处理数据的能力，使得我们可以更快地处理不断累积的海量数据。从20世纪80年代至今，CPU的制造工艺不断提升，晶体管数量不断增加（见图1-3），运行频率不断提高，核心（Core）数量逐渐增多，而同等价格所能获得的CPU处理能力也呈几何级数上升。在30多年里，CPU的处理速度已经从10 MHz提高到3.6 GHz，在2013年之前的很长一段时期，CPU处理速度的增加一直遵循“摩尔定律”，性能每隔18个月提高一倍，价格下降一半。\n\n![img](https://img-blog.csdnimg.cn/20200218141012311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmppYXlpbmE=,size_16,color_FFFFFF,t_70)\n\n**（3）网络带宽不断增加**\n\n移动通信宽带网络迅速发展，3G网络基本普及，4G网络覆盖范围不断加大，各种终端设备可以随时随地传输数据。大数据时代，信息传输不再遭遇网络发展初期的瓶颈和制约。\n\n![img](https://p.ananas.chaoxing.com/star3/origin/ccb7ae2cf066bb51215767bfc80d8ed8.png)\n\n# 大数据发展历程\n\n### 1 大数据的发展历程\n\n\n\n| 阶段                   | 时间                   | 内容                                                         |\n| ---------------------- | ---------------------- | ------------------------------------------------------------ |\n| 第一阶段：萌芽期       | 20世纪90年代至21世纪初 | 随着数据挖掘理论和数据库技术的逐步成熟，一批商业智能工具和知识管理技术开始被应用，如数据仓库、专家系统、知识管理新系统等 |\n| 第二阶段：成熟期       | 21世纪前10年           | Web2.0应用迅猛发展，非结构化数据大量产生，传统处理办法难以应对，带动了大数据技术的快速突破，大数据解决方案逐渐走向成熟，形成了并行计算与分布式系统两大核心技术，谷歌的GFS和Map Reduce等大数据技术受到追捧，Hadoop平台大行其道 |\n| 第三阶段：大规模应用期 | 2010年以后             | 大数据应用渗透各行各业，数据驱动决策，信息社会智能化程度大幅提高 |\n\n# 大数据的特点\n\n大数据的“4V”，或者说是大数据的4个特点，包含4个层面：\n\n**（1）数据量大（Volume）**\n\n大数据摩尔定律：根据IDC作出的估测，数据一直都在以每年50%的速度增长，也就是说每两年就增长一倍。人类在最近两年产生的数据量相当于之前产生的全部数据量。\n\n\n\n截至目前，人类生产的所有印刷材料的数据量是200PB，而历史上全人类总共说过的话的数据量大约是35EB。当前，典型个人计算机硬盘的容量为TB量级，而一些大企业的数据量已经接近EB量级。\n\n非结构化数据的超大规模和增长，导致数据集合的规模不断扩大，数据单位已从GB到TB再到PB级，甚至开始以EB和ZB来计数。\n\n**（2）数据类型繁多（Variety）**\n\n大数据的类型不仅包括网络日志、音频、视频、图片、地理位置信息等结构化数据，还包括半结构化数据甚至是非结构化数据，具有异构性和多样性的特点。\n\n**（3）处理速度快（Velocity）**\n\n要求大数据的处理速度快，时效性高，需要实时分析而非批量式分析，数据的输入、处理和分析连贯性地处理。\n\n **(4)  价值密度低（Value ）**\n\n大数据本身存在较大的潜在价值，但由于大数据的数据量过大，其价值往往呈现稀疏性的特点。虽然单位数据的价值密度在不断降低，但是数据的整体价值在提高。\n\n![img](https://img-blog.csdnimg.cn/img_convert/e62ede601d715a468a0121529111ca23.png)\n\n### 1 大数据对科学研究的影响\n\n ① 第一种范式，实验科学：在最初的科学研究阶段，人类采用实验来解决一些科学问题。\n\n ②第二种范式，理论科学：实验科学的研究会受到当时实验条件的限制，难以完成对自然现象更精确的理解。随着科学的进步，人类开始采用各种数学、几何、物理等理论，构建问题模型和解决方案。\n\n③第三种范式，计算科学：随着1946年人类历史上第一台计算机ENIAC的诞生，人类社会开始步入计算机时代，科学研究也进入了一个以“计算”为中心的全新时期。在实际应用中，计算科学主要用于对各个科学问题进行计算机模拟和其他形式的计算。通过设计算法并编写相应程序输入计算机运行，人类可以借助于计算机的高速运算能力去解决各种问题。计算机具有存储容量大、运算速度快、精度高、可重复执行等特点，是科学研究的利器，推动了人类社会的飞速发展。（先提出可能的理论，再搜集数据，然后通过计算来验证）\n\n ④第四种范式，数据密集型科学：随着数据的不断累积，其宝贵价值日益得到体现，物联网和云计算的出现，更是促成了事物发展从量变到质变的转变，使人类社会开启了全新的大数据时代。这时，计算机将不仅仅能做到模拟仿真，还能进行分析总结，得到理论。在大数据环境下，一切将以数据为中心，从数据中发现问题、解决问题，真正体现数据的价值。大数据将成为科学工作者的宝藏，从数据中可以挖掘未知模式和有价值的信息，服务于生产和生活，推动科技创新和社会进步。（先有了大量已知的数据，然后通过计算得出之前未知的理论）\n\n### 2 大数据对思维方式的影响\n\n ①全样而非抽样\n\n ②效率而非精确\n\n ③相关而非因果\n\n### 3 大数据对社会发展的影响\n\n ①大数据决策成为一种新的决策方式\n\n ②大数据应用促进信息技术与各行业的深度融合\n\n ③大数据开发推动新技术和新应用的不断涌现\n\n### 4  大数据对就业市场的影响\n\n大数据的兴起使得数据科学家成为热门人才。\n\n尽管有少数人认为未来有更多的数据会采用自动化处理，会逐步降低对数据科学家的需求，但是仍然有更多的人认为，随着数据科学家给企业所带来的商业价值的日益体现，市场对数据科学家的需求会越发旺盛。\n\n### 5 大数据对人才培养的影响\n\n大数据的兴起将在很大程度上改变中国高校信息技术相关专业的现有教学和科研体制。一方面，数据科学家是一个需要掌握统计、数学、机器学习、可视化、编程等多方面知识的复合型人才。另一方面，数据科学家需要大数据应用实战环境，在真正的大数据环境中不断学习、实践并融会贯通，将自身技术背景与所在行业业务需求进行深度融合，从数据中发现有价值的信息。\n\n高校培养数据科学家人才需要采取“两条腿”走路的策略，即“引进来”和“走出去”。所谓“引进来”，是指高校要加强与企业的紧密合作，从企业引进相关数据，为学生搭建起接近企业应用实际的、仿真的大数据实战环境，让学生有机会理解企业业务需求和数据形式，为开展数据分析奠定基础，同时从企业引进具有丰富实战经验的高级人才，承担起数据科学家相关课程教学任务，切实提高教学质量、水平和实用性。所谓“走出去”，是指积极鼓励和引导学生走出校园，进入互联网、金融、电信等具备大数据应用环境的企业去开展实践活动，同时努力加强产、学、研合作，创造条件让高校教师参与到企业大数据项目中，实现理论知识与实际应用的深层次融合，锻炼高校教师的大数据实战能力，为更好培养数据科学家人才奠定基础。', 0, '2022-09-06 10:26:14', '2022-10-21 20:01:00', 0, 121, 9, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/06/6fa092e312eb4c98a6f93ab4aab9bcc0.jpg', 7);
INSERT INTO `t_blog` VALUES (228, '注解和反射', 'JAVA学习之注解和反射', '注解\n◆Annotation是从JDK5.0开始引入的新技术.\n◆Annotation的作用 :\n➢不是程序本身,可以对程序作出解释(这- -点和注释(comment)没什么区别)\n➢可以被其他程序(比如:编译器等)读取.\n◆Annotation的格式:\n➢注解是以\"@注释名\"在代码中存在的, 还可以添加一-些参数值, 例\n如:@SuppressWarnings(value=\"unchecked\").\n◆Annotation在哪里使用?\n➢可以附加在package , class , method，field等上面,相当于给他们添加了额外的辅助信息，\n我们可以通过反射机制编程实现对这些元数据的访问\n内置注解\n➢@Override :定义在java.lang.Override中,此注释只适用于修辞方法,表示-一个方法声明打算\n重写超类中的另一个方法声明.\n➢@Deprecated :定义在java.lang.Deprecated中,此注释可以用于修辞方法,属性,类,表示不\n鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择.\n➢@SuppressWarnings :定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息.\n0与前两个注释有所不同,你需要添加一个参数才能正确使用，这些参数都是已经定义好了的,\n我们选择性的使用就好了.\nV @SuppressWarnings(\"ll\")\nV @SuppressWarnings(\"unchecked\")\nV @SuppressWarnings(value={\"unchecked\",\"deprecation\"})\nV等等.....\n元注解\n◆元注解的作用就是负责注解其他注解, Java定义了4个标准的meta -annotation类型，他们被用来\n提供对其他annotation类型作说明.\n◆>这些类型和它们所支持的类在java.lang .annotation包中可以找到.( @Target , @Retention，\n@Documented , @Inherited )\n➢@Target:用于描述注解的使用范围(即:被描述的注解可以用在什么地方)\n➢@Retention :表示需要在什么级别保存该注释信息,用于描述注解的生命周期\n➢(SOURCE < CL _ASS < RUNTIME)\n➢@Document:说明该注解将被包含在javadoc中\n➢@Inherited: 说明子类可以继承父类中的该注解\n//测试元注解\n```java\npublic class Test02 {\n@MyAnnotation\npublic void test(){\n}\n}\n//定义一个注解\n@Target(value = ElementType .METHOD)\n@interface MyAnnotation{\n}\n```\n\n\n 自定义注解\n➢使用@interface自定义注解时,自动继承了java.lang.annotation.Annotation接口\n➢分析:\nV @ interface用来声明一个注解,格式: public @ interface注解名{定义内容}\nV其中的每一个方法实际上是声明了一个配置参数.\nV方法的名称就是参数的名称.\nV返回值类型就是参数的类型(返回值只能是基本类型,Class , String，enum ).\nV可以通过default来声明参数的默认值\nV如果只有一个参数成员, -般参数名为value\nV注解元素必须要有值,我们定义注解元素时, 经常使用空字符串，0作为默认值.\n//自定义注解\n```java\npublic class Test03 {\n//注解可以显示赋值，如果没有默认值 ，我们就必须给注解赋值\n@MyAnnotation2(age = 18,name = \"小刘\")\npublic void test(){}\n@MyAnnotation3 (\"liu\")\npublic void test2(){\n@Target({ElementType. TYPE,ElementType . METHOD})\n@Retention (Retent ionPolicy . RUNTIME)\n@interface MyAnnotation2{\n//注解的参数:参数类型+参数名();\nStr ing name() default \"\";\nint age();\nint id() default -1;// 如果默认值为-1,代表不存在.\nString[] schools() default {\"大学\" , \"清华大学\"};\n@Target({ElementType. TYPE,ElementType .METHOD})\n@Retention (RetentionPolicy . RUNTIME)\n@interface MyAnnotation3{\nString value();\n```\n\n\n反射\n➢Reflection (反射)是Java被视为动态语言的关键，反射机制允许程序在执行期借\n助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及\n方法。\nClass C = Class forName(\"java.lang.String\")\n➢加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一 个类只有\n一个Class对象)， 这个对象就包含了完整的类的结构信息。我们可以通过这个对\n象看到类的结构。这个对象就像一-面镜子， 透过这个镜子看到类的结构，所以，\n我们形象的称之为:反射\n正常方式:\n引入 需要的\"包类”名称→ 通过new实例化 →[取得实例化对象\n反射方式:\n实例化对象 → getClass()方法 → 得到完整的“包类”名称\n\nJava反射机制提供的功能\n➢在运行时判断任意一个对象所属的类\n➢在运行时构造任意一个类的对象\n➢在运行时判断任意一个类所具有的成员变量和方法\n➢在运行时获取泛型信息\n➢在运行时调用任意一个对象的成员变量和方法\n➢在运行时处理注解\n➢生成动态代理\n➢\n........\n优点:\n➢可以实现动态创建对象和编译,体现出很大的灵活性\n缺点:\n➢对性能有影响。使用反射基本上是一-种解释操作,我们可以告诉JVM,我们希望\n做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。\nClass类\n对象照镜子后可以得到的信息:某个类的属性、方法和构造器、某个类到底实现了哪些接口\n对于每个类而言，JRE都为其保留一个不变的Class类型的对象。一个Class对象包含了特\n定某个结构(class/interface/enum/annotation/primitive type/void/])的有关信息。\n➢Class 本身也是一个类\n➢Class 对象只能由系统建立对象而69116\n➢一个加载的类在JVM中只会有一个Class实例\n➢一个Class对象对应的是一 个加载到JVM中的一个.class文件\n➢每个类的实例都会记得自己是由哪个Class实例所生成\n➢通过Class可以完整地得到一个类中的所有被加载的结构\n➢Class类是Reflection的根源， 针对任何你想动态加载、运行的类，唯有先获得相应的\nClass对象\n常用方法\n\n\n获取类的方法\na)若已知具体的类，通过类的class属性获取,该方法最为安全可靠，程序性能最高。\nClass clazz = Person.class;\nb)已知某个类的实例，调用该实例的getClass()方法获取Class对象\nClass clazz = person.getClass();\nc) 已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取,\n可能抛出ClassNotFoundException\nClass clazz = Class.forName(\"demo01 .Student\");\nd)内置基本数据类型可以直接用类名.Type\ne)还可以利用Classl oader我们之后讲解\n演示\n哪些类有class对象\n➢class: 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类。\n➢interface:接口\n➢[]:数组\n➢enum:枚举\nannotation:注解@interface\n➢primitive type: 基本数据类型\n➢\nvoid\n内存分析\n\n\n类加载过程\n\n\n类的加载与ClassLoader的理解\n➢加载:将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构,\n然后生成一个代表这个类的java.lang.Class对象.\n➢链接:将Java类的_ 二进制代码合并到JVM的运行状态之中的过程。\n➢验证: 确保加载的类信息符合JVM规范，没有安全方面的问题\n➢准备:正式为类变量(static) 分配内存并设置类变量默认初始值的阶段,这些内存都将在方法区中进行分配。\n➢解析:虚拟机常量池内的符号引用(常量名)替换为直接引用(地址)的过程。\n➢初始化:\n➢执行类构造器<clinit> ()方法的过程。类构造器<clinit> ()方法是由编译期自动收集类中所有类变量的赋值动作和静态\n代码块中的语句合并产生的。(类构造器 是构造类信息的，不是构造该类对象的构造器)。\n➢当初始化- -个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。\n➢虚拟机会保证- 个类的< clinit> ()方法在多线程环境中被正确加锁和同步。\n什么时候会发生类初始化?\n➢类的主动引用(- -定会发生类的初始化)\n➢当虚拟机启动，先初始化main方法所在的类\n➢new- -个类的对象\n➢调用类的静态成员(除了final常量)和静态方法\n➢使用java.lang.reflect包的方 法对类进行反射调用\n➢当初始化- -个类,如果其父类没有被初始化，则先会初始化它的父类\n➢类的被动引用(不会发生类的初始化)\n➢当访问一个静态域时，只有真正声明这个域的类才会被初始化。如:当通过子类引用父类的静态变量，不会导\n致子类初始化\n➢通过数组定义类引用，不会触发此类的初始化\n➢引用常量不会触发此类的初始化(常量在链接阶段就存入调用类的常量池中了)\n类加载器的作用\n➢类加载的作用:将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时\n数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问\n入口。\n➢类缓存:标准的JavaSE类加载器可以按要求查找类，但- -旦某个类被加载到类加载器中，它将维\n持加载(缓存)一段时间。不过JVM垃圾回收机制可以回收这些Class对象\n\n\n\n\n获取运行时类的完整结构\n通过反射获取运行时类的完整结构\nField、Method、 Constructor、 Superclass、 Interface、 Annotation\n➢实现的全部接口\nv\n➢所继承的父类\n➢全部的构造器\n➢全部的方法\n➢全部的Field\n➢注解\n➢。。。\n有了Class对象，能做什么?\n➢创建类的对象:调用Class对象的newInstance()方法\n➢1) 类必须有-个无参数的构造器。\n➢2)类的构造器的访问权限需要足够\n思考?难道没有无参的构造器就不能创建对象了吗?只要在操作的时候明确的调用类中的构造器,\n并将参数传递进去之后，才可以实例化操作。\n➢步骤如下:\n1)通过Class类的getDeclaredConstructor(Class .. parameterTypes)取得本类的指定形参类型的构\n造器\n```java\n2)向构造器的形参中传递一一个对象数组进去 ,里面包含了构造器中所需的各个参数。\n3)通过Constructor实例化对象\n//通过反射调用普通方法\nUser user3 = (User)c1. newInstance();\n//通过反射获取一个方法\nMethod setName = c1. getDeclaredMethod( name: \"setName\", Str ing. class);\n//invoke :激活的意思\n// (对象，\"方法的值\") \nsetName. invoke (user3, ..rgs.: \"xiaoliu\") ;\nSystem. out. pr intln(user3. getName());\n//通过反射操作属性\nSystem. out. pr intln(\"88888888888888888888888\") ;\nUser user4 = (User )c1. newIns tance() ;\nField name = c1. getDeclaredField( name: \"namel\"\') ;\n//不能直接操作私有属性，我们需 要关闭程序的安全检测，属性或 者方法的setAccessible(true)。\nname . setAccessible(true); //\nname . set(user4, \"xiaoliu2\");\nSystem.out. println(user4. getName());\n```\n\n\n反射操作泛型\n➢Java采用泛型擦除的机制来引入泛型, Java中的泛型仅仅是给编译器javac使用的,确保数据\n的安全性和免去强制类型转换问题,但是, - -旦编译完成,所有和泛型有关的类型全部擦除\n➢为了通过反射操作这些类型, Java新增了ParameterizedType , GenericArrayType，\nTypeVariable和WildcardType几种类型来代表不能被归一到Class类中的类型但是 又和原\n始类型齐名的类型.\n➢ParameterizedType :表示-种参数化类型，比如Collection<String>\n➢GenericArrayType :表示一种元素类型是参数化类型或者类型变量的数组类型\n➢TypeVariable :是各种类型变量的公共父接口\n➢WildcardType :代表- -种通配符类型表达式\n```java\npublic static void main(String[] args) throws NoSuchMethodException {\n    Method method = Test11.class. getMethod( name: \"test01\", Map.class, List.class);\n    Type[] genericPar ameterTypes = method. getGener icPar ameterTypes();\n    for (Type genericParameterType : gener icPar ameterTypes) {\n    System. out . pr intln(\"#\"+ gener icPar ameterType);\n    if (genericPar ameterType instanceof Par ameter izedType) {\n    Type[] actualTypeArguments = ((Parameter izedType) genericParameterType) .getActualTypeAr guments();\n    folr (Type actualTypeArgument : ac tualTypeAr guments) {\n    System.out .pr int ln( actualTypeAr gument) ;\n    }\n    }\n    method = Test11. class . getMethod( name: \"test02\"，..arameterTypes: null);\n    Type gener icReturnType\n    method. getGener icReturnType() ;\n    if (gener icReturnType instanceof Par ameterizedType){\n    Type[] actualTypeAr guments = ((Parameter izedType) gener icReturnType) . getActualTypeAr guments();\n    for (Type actualTypeAr gument : actua lTypeAr guments) {\n    System. out . pr intln(actualTypeAr gument) ;\n    }\n    }\n｝\n\n```\n', 0, '2022-09-06 23:31:13', '2022-10-21 20:01:00', 0, 1, 10, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/06/1179235c90cc4c858c59e3f047437e3c.jpg', 7);
INSERT INTO `t_blog` VALUES (230, '《路人》', NULL, ' ::: hljs-center\n\n《路人》\n		\n			  	  ——诗人西贝\n\n\n::: hljs-center\n\n不知为何，明明想和你说话。\n却骗你说，\n风雨正好，该去写点诗句。\n\n\n不必嘲讽我，你笑出声来，\n我也当是天籁。\n不必怀有敌意，你所有心计，\n我都当是你对我的心意。\n\n我的宿命分为两段，\n未遇见你时，和遇见你以后。\n你治好我的忧郁，而后赐我悲伤。\n忧郁和悲伤之间的片刻欢喜，透支了我生命全部的热情储蓄。\n想饮一些酒，让灵魂失重，好被风吹走。\n可一想到终将是你的路人，\n便觉得，沦为整个世界的路人。\n风虽大，都绕过我灵魂。\n\n:::\n', 0, '2022-09-08 01:36:47', '2022-10-21 20:01:00', 0, 118, 10, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/03/653c01916a9341d19943de27fc4b5587.jpg', 8);
INSERT INTO `t_blog` VALUES (231, 'logback.xml', NULL, '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!-- 级别从高到低 OFF 、 FATAL 、 ERROR 、 WARN 、 INFO 、 DEBUG 、 TRACE 、 ALL -->\n<!-- 日志输出规则 根据当前ROOT 级别，日志输出时，级别高于root默认的级别时 会输出 -->\n<!-- 以下 每个配置的 filter 是过滤掉输出文件里面，会出现高级别文件，依然出现低级别的日志信息，通过filter 过滤只记录本级别的日志 -->\n<!-- scan 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 -->\n<!-- scanPeriod 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 -->\n<!-- debug 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 -->\n<configuration scan=\"true\" scanPeriod=\"60 seconds\" debug=\"false\">\n\n    <!-- 动态日志级别 -->\n    <jmxConfigurator/>\n\n    <!--*****************************************************************************-->\n    <!--自定义项 开始-->\n    <!--*****************************************************************************-->\n\n    <!-- 定义日志文件 输出位置 -->\n    <property name=\"log.home_dir\" value=\"D:/java学习/xitong/logs\"/>\n    <property name=\"log.app_name\" value=\"http-demo\"/>\n    <!-- 日志最大的历史 30天 -->\n    <property name=\"log.maxHistory\" value=\"30\"/>\n    <property name=\"log.maxSize\" value=\"5MB\"/>\n    <!-- 日志界别 -->\n    <property name=\"log.level\" value=\"info\"/>\n    <!-- 打印sql语句 需要指定dao/mapper层包的位置 -->\n    <property name=\"mapper.package\" value=\"com.xiaoliu.system.mapper\"/>\n\n    <!-- 彩色日志 -->\n    <!-- 配置格式变量：CONSOLE_LOG_PATTERN 彩色日志格式 -->\n    <!-- magenta:洋红 -->\n    <!-- boldMagenta:粗红-->\n    <!-- cyan:青色 -->\n    <!-- white:白色 -->\n    <!-- magenta:洋红 -->\n    <property name=\"CONSOLE_LOG_PATTERN\"\n              value=\"%yellow(%date{yyyy-MM-dd HH:mm:ss}) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)\"/>\n\n    <!--*****************************************************************************-->\n    <!--自定义项 结束-->\n    <!--*****************************************************************************-->\n\n    <!-- ConsoleAppender 控制台输出日志 -->\n    <appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <pattern>\n                <!-- 设置日志输出格式 -->\n                ${CONSOLE_LOG_PATTERN}\n            </pattern>\n        </encoder>\n    </appender>\n\n    <!-- ERROR级别日志 -->\n    <!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 RollingFileAppender -->\n    <appender name=\"ERROR\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <!-- 过滤器，只记录WARN级别的日志 -->\n        <!-- 果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。 -->\n        <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n            <!-- 设置过滤级别 -->\n            <level>ERROR</level>\n            <!-- 用于配置符合过滤条件的操作 -->\n            <onMatch>ACCEPT</onMatch>\n            <!-- 用于配置不符合过滤条件的操作 -->\n            <onMismatch>DENY</onMismatch>\n        </filter>\n        <!-- 最常用的滚动策略，它根据时间来制定滚动策略.既负责滚动也负责触发滚动 -->\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n            <!--日志输出位置 可相对、和绝对路径 -->\n            <fileNamePattern>\n                ${log.home_dir}/error/%d{yyyy-MM-dd}/${log.app_name}-%i.log\n            </fileNamePattern>\n            <!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件,假设设置每个月滚动，且<maxHistory>是6，\n            则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除 -->\n            <maxHistory>${log.maxHistory}</maxHistory>\n            <!--日志文件最大的大小-->\n            <MaxFileSize>${log.maxSize}</MaxFileSize>\n        </rollingPolicy>\n        <encoder>\n            <pattern>\n                <!-- 设置日志输出格式 -->\n                %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n\n            </pattern>\n        </encoder>\n    </appender>\n\n\n    <!-- WARN级别日志 appender -->\n    <appender name=\"WARN\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <!-- 过滤器，只记录WARN级别的日志 -->\n        <!-- 果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。 -->\n        <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n            <!-- 设置过滤级别 -->\n            <level>WARN</level>\n            <!-- 用于配置符合过滤条件的操作 -->\n            <onMatch>ACCEPT</onMatch>\n            <!-- 用于配置不符合过滤条件的操作 -->\n            <onMismatch>DENY</onMismatch>\n        </filter>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n            <!--日志输出位置 可相对、和绝对路径 -->\n            <fileNamePattern>${log.home_dir}/warn/%d{yyyy-MM-dd}/${log.app_name}-%i.log</fileNamePattern>\n            <maxHistory>${log.maxHistory}</maxHistory>\n            <!--当天的日志大小 超过MaxFileSize时,压缩日志并保存-->\n            <MaxFileSize>${log.maxSize}</MaxFileSize>\n        </rollingPolicy>\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>\n        </encoder>\n    </appender>\n\n\n    <!-- INFO级别日志 appender -->\n    <appender name=\"INFO\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n            <level>INFO</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n            <fileNamePattern>${log.home_dir}/info/%d{yyyy-MM-dd}/${log.app_name}-%i.log</fileNamePattern>\n            <maxHistory>${log.maxHistory}</maxHistory>\n            <MaxFileSize>${log.maxSize}</MaxFileSize>\n        </rollingPolicy>\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %logger - %msg%n</pattern>\n        </encoder>\n    </appender>\n\n\n    <!-- DEBUG级别日志 appender -->\n    <appender name=\"DEBUG\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n            <level>DEBUG</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n            <fileNamePattern>${log.home_dir}/debug/%d{yyyy-MM-dd}/${log.app_name}-%i.log</fileNamePattern>\n            <maxHistory>${log.maxHistory}</maxHistory>\n            <MaxFileSize>${log.maxSize}</MaxFileSize>\n        </rollingPolicy>\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %logger - %msg%n</pattern>\n        </encoder>\n    </appender>\n\n\n    <!-- TRACE级别日志 appender -->\n    <appender name=\"TRACE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n            <level>TRACE</level>\n            <onMatch>ACCEPT</onMatch>\n            <onMismatch>DENY</onMismatch>\n        </filter>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n            <fileNamePattern>${log.home_dir}/trace/%d{yyyy-MM-dd}/${log.app_name}-%i.log</fileNamePattern>\n            <maxHistory>${log.maxHistory}</maxHistory>\n            <MaxFileSize>${log.maxSize}</MaxFileSize>\n        </rollingPolicy>\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %logger - %msg%n</pattern>\n        </encoder>\n    </appender>\n\n\n    <!--设置一个向上传递的appender,所有级别的日志都会输出-->\n    <appender name=\"app\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n            <fileNamePattern>${log.home_dir}/app/%d{yyyy-MM-dd}/${log.app_name}-%i.log</fileNamePattern>\n            <maxHistory>${log.maxHistory}</maxHistory>\n            <MaxFileSize>${log.maxSize}</MaxFileSize>\n        </rollingPolicy>\n        <encoder>\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %logger - %msg%n</pattern>\n        </encoder>\n    </appender>\n\n\n    <!--org.springframework.web包下的类的日志输出-->\n    <logger name=\"org.springframework.web\" additivity=\"false\" level=\"WARN\">\n        <appender-ref ref=\"WARN\"/>\n    </logger>\n    <!--dao层包下的类的日志输出-->\n    <logger name=\"${mapper.package}\" additivity=\"false\" level=\"DEBUG\">\n        <appender-ref ref=\"app\"/>\n        <appender-ref ref=\"ERROR\"/>\n        <!--打印控制台-->\n        <appender-ref ref=\"CONSOLE\"/>\n    </logger>\n\n\n    <!-- root级别   DEBUG -->\n    <root>\n        <!-- 打印debug级别日志及以上级别日志 -->\n        <level value=\"${log.level}\"/>\n        <!-- 控制台输出 -->\n        <appender-ref ref=\"CONSOLE\"/>\n        <!-- 不管什么包下的日志都输出文件 -->\n        <appender-ref ref=\"ERROR\"/>\n        <appender-ref ref=\"INFO\"/>\n        <appender-ref ref=\"WARN\"/>\n        <appender-ref ref=\"DEBUG\"/>\n        <appender-ref ref=\"TRACE\"/>\n    </root>\n</configuration>\n\n', 0, '2022-09-09 16:16:50', '2022-10-21 20:01:00', 0, 1, 4, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/06/6fa092e312eb4c98a6f93ab4aab9bcc0.jpg', 7);
INSERT INTO `t_blog` VALUES (232, 'mybatiUtil', 'mybatis工具类', '\n```java\n/**\n * @author: 61分\n * @date: 2022/9/9 15:53\n * @description:\n */\n\n    private static SqlSessionFactory sqlSessionFactory;\n    static {\n        try {\n            InputStream inputStream = Resources.getResourceAsStream(\"mybatis.xml\");\n            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static SqlSession getSqlSession(){\n        return sqlSessionFactory.openSession();\n    }\n}\n```\n\n', 0, '2022-09-09 16:26:54', '2022-10-21 20:01:00', 0, 124, 8, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/09/670685b9a0fa4dae860db88ed6f82db1.png', 7);
INSERT INTO `t_blog` VALUES (233, 'SpringIOC', 'IOC底层原理1', '# spring\n\n## 1、spring是什么？\n\n- Spring框架是一个[开放源代码](https://baike.baidu.com/item/开放源代码/114160?fromModule=lemma_inlink)的[J2EE](https://baike.baidu.com/item/J2EE/110838?fromModule=lemma_inlink)应用程序框架，由[Rod Johnson](https://baike.baidu.com/item/Rod Johnson/1423612?fromModule=lemma_inlink)发起，是针对bean的生命周期进行管理的轻量级容器（lightweight container）。 \n- Spring解决了开发者在J2EE开发中遇到的许多常见的问题，提供了功能强大IOC、[AOP](https://baike.baidu.com/item/AOP/1332219?fromModule=lemma_inlink)及Web MVC等功能。 Spring可以单独应用于构筑应用程序，也可以和Struts、Webwork、Tapestry等众多Web框架组合使用，并且可以与 Swing等[桌面应用程序](https://baike.baidu.com/item/桌面应用程序/2331979?fromModule=lemma_inlink)AP组合。因此， Spring不仅仅能应用于J2EE应用程序之中，也可以应用于桌面应用程序以及小应用程序之中。\n- Spring框架主要由七部分组成，分别是 **Spring Core**、 **Spring AOP**、 **Spring ORM**、 **Spring DAO**、**Spring Context**、 **Spring Web**和 **Spring Web MVC**\n\n## **2、**Spring两个核心：IOC、AOP\n\n### IOC(控制反转 Inversion of Control)\n\n（1）把创建对象的过程交由spring框架管理\n\n###  AOP(面向切面 Aspect Oriented Programming)\n\n(1) 不修改源代码的情况下，对程序进行功能增强\n\n## 3、spring特点\n\n（1）方便解耦，简化开发\n\n（2）AOP编程的支持\n\n（3）方便整合其他的框架\n\n（4）很好的有JAVAEE API的使用难度\n\n（5）方便事务的操作\n\n# spring模块\n\n![image20220908211310093.png](http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/09/b4ea827ecfbe4bcfbc3babbd6a256cc3.png)\n\n# 4、入门案例\n\n1、导包\n\n```java\n<!--        //beans-->\n\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-beans</artifactId>\n  <version>5.3.22</version>\n</dependency>\n<!--        //core-->\n\n    <dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-core</artifactId>\n  <version>5.3.22</version>\n</dependency>\n<!--        //context-->\n    <dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-context</artifactId>\n  <version>5.3.22</version>\n</dependency>\n```\n\n2、实体类\n\n```java\n /**\n * @author: 61分\n * @date: 2022/9/8 21:58\n * @description:\n */\npublic class User {\n    private String name;\n    private Integer id;\n\n    public String getName() {\n        return name;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public User() {\n    }\n\n    public User(String name, Integer id, Integer age) {\n        this.name = name;\n        this.id = id;\n        this.age = age;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    private Integer age;\n\n}\n```\n\n3、bean(需要放在resource目录下)\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"User\" class=\"com.xiaoliu.entity.User\"></bean>\n\n</beans>\n```\n\n4、进行代码测试\n\n```java\npublic class TestSpring {\n\n    @Test\n    public void test(){\n        //1、加载spring的配置文件\n        ApplicationContext context =\n                new ClassPathXmlApplicationContext(\"bean1.xml\");\n//        2、获取配置创建的对象\n        User user = context.getBean(\"User\", User.class);\n        System.out.println(user);\n//\n    }\n}\n```\n\n# IOC容器\n\n## 什么是IOC？\n\n**控制反转**（Inversion of Control，缩写为**IoC**），是[面向对象编程](https://baike.baidu.com/item/面向对象编程/254878?fromModule=lemma_inlink)中的一种设计原则，可以用来减低计算机[代码](https://baike.baidu.com/item/代码/86048?fromModule=lemma_inlink)之间的[耦合度](https://baike.baidu.com/item/耦合度/2603938?fromModule=lemma_inlink)。其中最常见的方式叫做**[依赖注入](https://baike.baidu.com/item/依赖注入/5177233?fromModule=lemma_inlink)**（Dependency Injection，简称**DI**），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。\n\n## 1、底层原理\n\n （1）xml解析、工厂模式、反射\n\n（2）IOC原理（图解）\n\n### 原始的做法：\n\n普通模式：\n![image20220909222358714.png](http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/09/e5da958557e44ce58663a2572f09b719.png)\n\n工厂模式：\n\n\n![image20220909222855262.png](http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/09/74dac8e588d14a2daae883fe1392db40.png)\n### IOC过程：\n\n![image20220909223418876.png](http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/09/b8d74e0f6848430e860b1128fd6c726b.png)\n\n### IOC（接口）\n\n1、ioc思想基于ioc容器，ioc容器本质是对象工厂\n\n2、Spring提供IOC实现的两种方式\n\n- BeanFactory（最基本的实现方式），是spring内部使用的接口，不提供给开发人员实现\n\n**特点**：加载配置文件时，不会创建里面的对象，在使用时才去创建\n\n- ApplicationContext:BeanFactory的子接口，提供更多更强大的功能，一般面向开发人员使用\n\n**特点**，在加载配置文件时，就会把在配置文件中的对象进行创建\n\n3、ApplicationContext接口中有实现类\n\n![image20220909224428894.png](http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/09/5388fcb18ca140e1aebc226d2dc2d293.png)', 0, '2022-09-09 23:05:19', '2022-10-21 20:01:00', 0, 123, 5, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/09/b4ea827ecfbe4bcfbc3babbd6a256cc3.png', 7);
INSERT INTO `t_blog` VALUES (234, '网站问题汇总', 'BUG', '## 1、按照标签或类别，查找文章时，分页bug\n预处理：按照标签或类别查找时，不进行分页，查出全部\n### 已解决✅\n## 2、编辑文章时，缓存没有更新，\n预处理：编辑时，删除缓存，重新获取\n## 3、可以添加视频页面\n## 4、后台主页部分可以添加东西\n## 5、标签悬停没有立体感\n预处理：添加标签或类别鼠标悬停效果\n### 已解决✅\n## 6、缓存时，评论打开时，创建时间显示的是时间戳\n预处理：后台缓存存入的是经过序列化的，显示问题可能是出在前端。\n## 7、移动端不做了，\n## 8、后台留言板的数据被遮盖。前端显示样式的问题\n预处理：暂时不知道咋做\n## 9、网页感觉有点单调，多看看别人的博客\n## 10、网站图标可以大一点\n## 11、在首页文章查找的时候，没有跳转到目标页\n## 12、博客详情页面即预览页面的背景可以透明一点\n## 13、el-card鼠标悬停的阴影效果弄成黑色要好点，不要白色\n## 14、还有后台退出登录时，把那个中间提示换成右边弹出，每次都挡着😡', 0, '2022-09-09 23:42:48', '2022-10-21 20:01:00', 1, 118, 40, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/03/896c734fbcb64374b44d837e33975cd7.jpg', 9);
INSERT INTO `t_blog` VALUES (235, '操作系统第一章总结', '思维导图', '::: hljs-center\n\n**📕来自罗同学总结的思维导图**\n\n:::\n💡 ++(非原创)++\n\n![来自罗同学总结的思维导图](http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/11/e8a8d5d2ce9d4c37a273b09b9ac03b38.png)', 0, '2022-09-11 22:15:27', '2022-10-21 20:01:00', 0, 122, 7, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/11/e8a8d5d2ce9d4c37a273b09b9ac03b38.png', 7);
INSERT INTO `t_blog` VALUES (236, 'Mybatis02', 'mybatis02', '**Map和模糊查询**\n\n可以使用map进行传值，\n\n参数过多的时候可以使用map\n\n**但是不好维护。**\n\n**配置**\n\nMyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下：\n\n- configuration（配置）\n\n- - properties（属性）\n\n  - settings（设置）\n\n  - typeAliases（类型别名）\n\n  - typeHandlers（类型处理器）\n\n  - objectFactory（对象工厂）\n\n  - plugins（插件）\n\n  - environments（环境配置）\n\n  - - environment（环境变量）\n\n    - - transactionManager（事务管理器）\n      - dataSource（数据源）\n\n  - databaseIdProvider（数据库厂商标识）\n\n  - mappers（映射器）\n\n**属性**\n\n配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <typeAliases>\n        <typeAlias type=\"com.xiaoliu.entity.User\" alias=\"User\"/>\n    </typeAliases>\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/jdbc?userUnicode=true;characterEncoding=utf8;serverTimezone=UTC\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"123456\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <mappers>\n        <mapper resource=\"mapper/UserMapper.xml\"/>\n    </mappers>\n</configuration>\n\n```\n\n**环境配置**\n\nMYBATIS可以适应多种环境\n\n但**SqlSessionFactory**实例只能使用一种环境\n\nMYBATIS默认的事务管理器 是JDBC 连接池：JDBC ，默认的环境为development\n\n**引入外部配置文件**\n\n```xml	\n例如\n新建db.properties文件\njdbc.driver=com.mysql.cj.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/8&serverTimezone=GMT%2B8\njdbc.username=root\njdbc.password=\njdbc.initPoolSize = 5\njdbc.maxPoolSize=10\n\n新建mybatis XML文件\n登录后复制\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\nPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n\"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n<!--引入外部属性文件-->\n<properties resource=\"db.properties\"></properties>\n<!--环境配置-->\n<environments default=\"development\">\n    <environment id=\"development\">\n        <transactionManager type=\"JDBC\"/>\n        <dataSource type=\"POOLED\">\n            <property name=\"driver\" value=\"${jdbc.driver}\"/>\n            <property name=\"url\" value=\"${jdbc.url}\"/>\n            <property name=\"username\" value=\"${jdbc.username}\"/>\n            <property name=\"password\" value=\"${jdbc.password}\"/>\n        </dataSource>\n    </environment>\n</environments>\n\n<!--映射写好的SQL映射文件，并且注册到全局配置文件mybatis-config中-->\n<mappers>\n    <mapper resource=\"EmployeeMapper.xml\"></mapper>\n</mappers>\n</configuration>\n```\n\n\n\n **解决属性名和字段名不一致的问题**\n\n**resultMap**\n\n结果集映射\n\n实体类\n\n\n\n```java\nprivate Integer id;\nprivate String address;\nprivate String useraddress;\nprivate Integer age;\nprivate Integer userage;\n```\n\n```xml	\n<!--                            type是需要映射的实体-->\n    <resultMap id=\"UserMap\" type=\"User\">\n<!--        column是字段，property实体的属性-->\n        <result column=\"id\" property=\"id\"/>\n        <result column=\"name\" property=\"username\"/>\n        <result column=\"age\" property=\"userage\"/>\n        <result column=\"address\" property=\"useraddress\"/>\n    </resultMap>\n    <select id=\"getUserListByMap\" resultMap=\"UserMap\">\n        select * from people;\n    </select>\n```\n\n```java\n@Test\npublic void TestByMap(){\n    UserService userService = new UserImpl();\n    List<User> list = userService.getUserListByMap();\n    for (User user1 : list) {\n        System.out.println(\"id:\"+user1.getId()+\"name:\"+user1.getUsername()+\"age:\"+user1.getUserage()+\"address:\"+user1.getUseraddress()+\"\\n\");\n    }\n}\n```\n\n\n\n结果\n\n![截图.png](http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/12/ca1575115ff8453093230536a4336a45.png)\n\n**高级映射**\n\n**日志工厂**\n\n| logImpl | 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 | SLF4J \\| LOG4J \\| LOG4J2 \\| JDK_LOGGING \\| COMMONS_LOGGING \\| STDOUT_LOGGING \\| NO_LOGGING | 未设置 |\n| ------- | ----------------------------------------------------- | ------------------------------------------------------------ | ------ |\n|         |                                                       |                                                              |        |\n\n开启日志\n\n```xml\n<settings>\n    <setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>\n</settings>\n```\n\n**LOG4J**\n\n什么是LOG4J\n\n Log4j是[Apache](https://baike.baidu.com/item/Apache/8512995?fromModule=lemma_inlink)的一个开源项目\n\n我们可以控制日志信息输送的目的地是[控制台](https://baike.baidu.com/item/控制台/2438626?fromModule=lemma_inlink)、文件、[GUI](https://baike.baidu.com/item/GUI?fromModule=lemma_inlink)组件，甚至是套接口服务器、[NT](https://baike.baidu.com/item/NT/3443842?fromModule=lemma_inlink)的事件记录器、[UNIX](https://baike.baidu.com/item/UNIX?fromModule=lemma_inlink) [Syslog](https://baike.baidu.com/item/Syslog?fromModule=lemma_inlink)[守护进程](https://baike.baidu.com/item/守护进程/966835?fromModule=lemma_inlink)等；\n\n我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。\n\n1、先导包\n\n```xml\n<dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.17</version>\n</dependency>\n```\n\n2、配置文件\n\nlog4j.properties\n\n```prop\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\nlog4j.rootLogger=DEBUG,console,file\n\n#控制台输出的相关设置\nlog4j.appender.console = org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target = System.out\nlog4j.appender.console.Threshold=DEBUG\nlog4j.appender.console.layout = org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n\n\n#文件输出的相关设置\nlog4j.appender.file = org.apache.log4j.RollingFileAppender\nlog4j.appender.file.File=./log/logFile.log\nlog4j.appender.file.MaxFileSize=10mb\nlog4j.appender.file.Threshold=DEBUG\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n\n\n#日志输出级别\nlog4j.logger.org.mybatis=DEBUG\nlog4j.logger.java.sql=DEBUG\nlog4j.logger.java.sql.Statement=DEBUG\nlog4j.logger.java.sql.ResultSet=DEBUG\nlog4j.logger.java.sql.PreparedStatement=DEBUG\n\n```\n\n3、在核心配置文件中开启日志\n\n```xml\n<settings>\n    <setting name=\"logImpl\" value=\"LOG4J\"/>\n</settings>\n```\n\n**开启驼峰命名**\n\n```xml\n<settings>\n    <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\n</settings>\n```\n\n**面向注解开发**\n\n注解的底层是反射\n\n```java\n@Select(\"select * from people\")\n@Results({\n	@Result(id=true,property=\"id\",column=\"id\"),\n	@Result(property=\"name\",column=\"name\"),\n	@Result(property=\"age\",column=\"age\"),\n        @Result(property=\"address\",column=\"address\"),\n})\npublic List<User> getAllUser();\n```\n![qwe.png](http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/12/3f3b56b0348146ef80e220e018bad582.png)', 0, '2022-09-12 23:46:02', '2022-10-21 20:01:00', 0, 124, 3, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/12/3f3b56b0348146ef80e220e018bad582.png', 7);
INSERT INTO `t_blog` VALUES (237, 'mybatis03', '学习mybatis笔记', '# **mybatis执行流程**\n\nMybatis核心类：\n\n**SqlSessionFactory**：每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或通过Java的方式构建出 SqlSessionFactory 的实例。SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，建议使用单例模式或者静态单例模式。一个SqlSessionFactory对应配置文件中的一个环境（environment），如果你要使用多个数据库就配置多个环境分别对应一个SqlSessionFactory。\n\n**SqlSession**：SqlSession是一个接口，它有2个实现类，分别是DefaultSqlSession(默认使用)以及SqlSessionManager。SqlSession通过内部存放的执行器（Executor）来对数据进行CRUD。此外SqlSession不是线程安全的，因为每一次操作完数据库后都要调用close对其进行关闭，官方建议通过try-finally来保证总是关闭SqlSession。\n\n**Executor**：Executor（执行器）接口有两个实现类，其中BaseExecutor有三个继承类分别是BatchExecutor（重用语句并执行批量更新），ReuseExecutor（重用预处理语句prepared statement，跟Simple的唯一区别就是内部缓存statement），SimpleExecutor（默认，每次都会创建新的statement）。以上三个就是主要的Executor。通过下图可以看到Mybatis在Executor的设计上面使用了装饰器模式，我们可以用CachingExecutor来装饰前面的三个执行器目的就是用来实现缓存。\n\n![截图2](http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/13/4674a8e5ed2443d1880223bbf1c6c689.png)\n\n**MappedStatement：**MappedStatement就是用来存放我们SQL映射文件中的信息包括sql语句，输入参数，输出参数等等。一个SQL节点对应一个MappedStatement对象。\n\n![截图3.png](http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/13/f7335491a70940f4927f816b69d614b6.png)\n\n第一步通过SqlSessionFactoryBuilder创建SqlSessionFactory：\n\n首先在SqlSessionFactoryBuilder的build（）方法中可以看到MyBatis内部定义了一个类XMLConfigBuilder用来解析配置文件mybatis-config.xml。针对配置文件中的每一个节点进行解析并将数据存放到Configuration这个对象中，紧接着使用带有Configuration的构造方法发返回一个DefautSqlSessionFactory。\n\n```java\n  public SqlSessionFactory build(InputStream inputStream) {\n    return build(inputStream, null, null);\n  }\n \n  public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {\n    try {\n      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);\n      //解析mybatis-config.xml\n      return build(parser.parse());\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e);\n    } finally {\n      ErrorContext.instance().reset();\n      try {\n        inputStream.close();\n      } catch (IOException e) {\n        // Intentionally ignore. Prefer previous error.\n      }\n    }\n  }\n    \n  //返回SqlSessionFactory，默认使用的是实现类DefaultSqlSessionFactory\n  public SqlSessionFactory build(Configuration config) {\n    return new DefaultSqlSessionFactory(config);\n  }\n \n  public Configuration parse() {\n    if (parsed) {\n      throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\");\n    }\n    parsed = true;\n    //获取根节点configuration\n    parseConfiguration(parser.evalNode(\"/configuration\"));\n    return configuration;\n  }\n \n  //开始解析mybatis-config.xml,并把解析后的数据存放到configuration中\n  private void parseConfiguration(XNode root) {\n    try {\n      //保存mybatis-config.xml中的标签setting,本例中开启全局缓存cacheEnabled，设置默认执行器defaultExecutorType=REUSE\n      Properties settings = settingsAsPropertiess(root.evalNode(\"settings\"));\n      //issue #117 read properties first\n      //解析是否配置了外部properties，例如本例中配置的jdbc.propertis\n      propertiesElement(root.evalNode(\"properties\"));\n      //查看是否配置了VFS，默认没有，本例也没有使用\n      loadCustomVfs(settings);\n      //查看是否用了类型别名，减少完全限定名的冗余，本例中使用了别名User代替了com.ctc.Model.User\n      typeAliasesElement(root.evalNode(\"typeAliases\"));\n      //查看是否配置插件来拦截映射语句的执行，例如拦截Executor的Update方法，本例没有使用\n      pluginElement(root.evalNode(\"plugins\"))\n      //查看是否配置了ObjectFactory，默认情况下使用对象的无参构造方法或者是带有参数的构造方法，本例没有使用\n      objectFactoryElement(root.evalNode(\"objectFactory\"));\n      //查看是否配置了objectWrapperFatory,这个用来或者ObjectWapper，可以访问：对象，Collection，Map属性。本例没有使用\n      objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\"));\n      //查看是否配置了reflectorFactory,mybatis的反射工具，提供了很多反射方法。本例没有使用\n      reflectorFactoryElement(root.evalNode(\"reflectorFactory\"));\n      //放入参数到configuration对象中\n      settingsElement(settings);\n      // read it after objectFactory and objectWrapperFactory issue #631\n      //查看数据库环境配置\n      environmentsElement(root.evalNode(\"environments\"));\n      //查看是否使用多种数据库，本例没有使用\n      databaseIdProviderElement(root.evalNode(\"databaseIdProvider\"));\n      //查看是否配置了新的类型处理器，如果跟处理的类型跟默认的一致就会覆盖。本例没有使用\n      typeHandlerElement(root.evalNode(\"typeHandlers\"));\n      //查看是否配置SQL映射文件,有四种配置方式，resource，url，class以及自动扫包package。本例使用package\n      mapperElement(root.evalNode(\"mappers\"));\n    } catch (Exception e) {\n      throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e);\n    }\n  }\n \n```\n\n第二步通过SqlSessionFactory创建SqlSession：\n\n```java\n  @Override\n  public SqlSession openSession() {\n    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);\n  }\n \n \n  private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {\n    Transaction tx = null;\n    try {\n      //拿到前文从mybatis中解析到的数据库环境配置\n      final Environment environment = configuration.getEnvironment();\n      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);\n      //拿到jdbc的事务管理器，有两种一种是jbc,一种的managed。本例使用的是JdbcTransaction\n      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);\n      //从mybatis配置文件可以看到本例使用了REUSE，因此返回的是ReuseExecutor并把事务传入对象中\n      final Executor executor = configuration.newExecutor(tx, execType);\n      return new DefaultSqlSession(configuration, executor, autoCommit);\n    } catch (Exception e) {\n      closeTransaction(tx); // may have fetched a connection so lets call close()\n      throw ExceptionFactory.wrapException(\"Error opening session.  Cause: \" + e, e);\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n \n \n  public Executor newExecutor(Transaction transaction, ExecutorType executorType) {\n    executorType = executorType == null ? defaultExecutorType : executorType;\n    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;\n    Executor executor;\n    if (ExecutorType.BATCH == executorType) {\n      executor = new BatchExecutor(this, transaction);\n    } else if (ExecutorType.REUSE == executorType) {\n      executor = new ReuseExecutor(this, transaction);\n    } else {\n      executor = new SimpleExecutor(this, transaction);\n    }\n    if (cacheEnabled) {\n      executor = new CachingExecutor(executor);\n    }\n    executor = (Executor) interceptorChain.pluginAll(executor);\n    return executor;\n  }\n \n  //返回一个SqlSession，默认使用DefaultSqlSession\n  public DefaultSqlSession(Configuration configuration, Executor executor, boolean autoCommit) {\n    this.configuration = configuration;\n    this.executor = executor;\n    this.dirty = false;\n    this.autoCommit = autoCommit;\n  }\n```\n\n第三步通过SqlSession拿到Mapper对象的代理：\n\n```java\n  @Override\n  public <T> T getMapper(Class<T> type) {\n    return configuration.<T>getMapper(type, this);\n  }\n \n  public <T> T getMapper(Class<T> type, SqlSession sqlSession) {\n    //前文解析Mybatis-config.xml的时候，在解析标签mapper就是用configuration对象的mapperRegistry存放数据\n    return mapperRegistry.getMapper(type, sqlSession);\n  }\n \n  @SuppressWarnings(\"unchecked\")\n  public <T> T getMapper(Class<T> type, SqlSession sqlSession) {\n    //knownMapper是一个HashMap在存放mapperRegistry的过程中，以每个Mapper对象的类型为Key, MapperProxyFactory 为value保存。\n    //例如本例中保存的就是Key:com.ctc.mapper.UserMapper,value就是保存了key的MapperProxyFactory对象\n    final MapperProxyFactory<T> mapperProxyFactory = (MapperProxyFactory<T>) knownMappers.get(type);\n    if (mapperProxyFactory == null) {\n      throw new BindingException(\"Type \" + type + \" is not known to the MapperRegistry.\");\n    }\n    try {\n      return mapperProxyFactory.newInstance(sqlSession);\n    } catch (Exception e) {\n      throw new BindingException(\"Error getting mapper instance. Cause: \" + e, e);\n    }\n  }\n \n  public T newInstance(SqlSession sqlSession) {\n    //生成一个mapperProxy对象，这个对象实现了InvocationHandler, Serializable。就是JDK动态代理中的方法调用处理器\n    final MapperProxy<T> mapperProxy = new MapperProxy<T>(sqlSession, mapperInterface, methodCache);\n    return newInstance(mapperProxy);\n  }\n \n  public MapperProxy(SqlSession sqlSession, Class<T> mapperInterface, Map<Method, MapperMethod> methodCache) {\n    this.sqlSession = sqlSession;\n    this.mapperInterface = mapperInterface;\n    this.methodCache = methodCache;\n  }\n \n  @SuppressWarnings(\"unchecked\")\n  protected T newInstance(MapperProxy<T> mapperProxy) {\n    //通过JDK动态代理生成一个Mapper的代理，在本例中的就是UserMapper的代理类，它实现了UserMapper接口\n    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);\n  }\n \n```\n\n第四步通过MapperProxy调用Maper中相应的方法：\n\n```java\n  @Override\n  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n   //判断当前调用的method是不是Object中声明的方法，如果是的话直接执行。\n   if (Object.class.equals(method.getDeclaringClass())) {\n      try {\n        return method.invoke(this, args);\n      } catch (Throwable t) {\n        throw ExceptionUtil.unwrapThrowable(t);\n      }\n    }\n    final MapperMethod mapperMethod = cachedMapperMethod(method);\n    return mapperMethod.execute(sqlSession, args);\n  }\n \n  //把当前请求放入一个HashMap中，一旦下次还是同样的方法进来直接返回。\n  private MapperMethod cachedMapperMethod(Method method) {\n    MapperMethod mapperMethod = methodCache.get(method);\n    if (mapperMethod == null) {\n      mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration());\n      methodCache.put(method, mapperMethod);\n    }\n    return mapperMethod;\n  }\n \n  public Object execute(SqlSession sqlSession, Object[] args) {\n    Object result;\n    switch (command.getType()) {\n      case INSERT: {\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.insert(command.getName(), param));\n        break;\n      }\n      case UPDATE: {\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.update(command.getName(), param));\n        break;\n      }\n      case DELETE: {\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = rowCountResult(sqlSession.delete(command.getName(), param));\n        break;\n      }\n      case SELECT:\n        if (method.returnsVoid() && method.hasResultHandler()) {\n          executeWithResultHandler(sqlSession, args);\n          result = null;\n        } else if (method.returnsMany()) {\n          result = executeForMany(sqlSession, args);\n        } else if (method.returnsMap()) {\n          result = executeForMap(sqlSession, args);\n        } else if (method.returnsCursor()) {\n          result = executeForCursor(sqlSession, args);\n        } else {\n          //本次案例会执行selectOne\n          Object param = method.convertArgsToSqlCommandParam(args);\n          result = sqlSession.selectOne(command.getName(), param);\n        }\n        break;\n      case FLUSH:\n        result = sqlSession.flushStatements();\n        break;\n      default:\n        throw new BindingException(\"Unknown execution method for: \" + command.getName());\n    }\n    if (result == null && method.getReturnType().isPrimitive() && !method.returnsVoid()) {\n      throw new BindingException(\"Mapper method \'\" + command.getName() \n          + \" attempted to return null from a method with a primitive return type (\" + method.getReturnType() + \").\");\n    }\n    return result;\n  }\n \n  @Override\n  public <T> T selectOne(String statement, Object parameter) {\n    // Popular vote was to return null on 0 results and throw exception on too many.\n    List<T> list = this.<T>selectList(statement, parameter);\n    if (list.size() == 1) {\n      return list.get(0);\n    } else if (list.size() > 1) {\n      throw new TooManyResultsException(\"Expected one result (or null) to be returned by selectOne(), but found: \" + list.size());\n    } else {\n      return null;\n    }\n  }\n \n  @Override\n  public <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds) {\n    try {\n      MappedStatement ms = configuration.getMappedStatement(statement);\n      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(\"Error querying database.  Cause: \" + e, e);\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n \n  //这边调用的是CachingExecutor类的query,还记得前文解析mybatis-config.xml的时候我们指定了REUSE但是因为在配置文件中开启了缓存\n  //所以ReuseExecutor被CachingExecotur装饰，新增了缓存的判断，最后还是会调用ReuseExecutor\n  @Override\n  public <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {\n    BoundSql boundSql = ms.getBoundSql(parameterObject);\n    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);\n    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n  }\n \n  @Override\n  public <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)\n      throws SQLException {\n    Cache cache = ms.getCache();\n    if (cache != null) {\n      flushCacheIfRequired(ms);\n      if (ms.isUseCache() && resultHandler == null) {\n        ensureNoOutParams(ms, parameterObject, boundSql);\n        @SuppressWarnings(\"unchecked\")\n        List<E> list = (List<E>) tcm.getObject(cache, key);\n        if (list == null) {\n          //如果缓存中没有数据则查询数据库\n          list = delegate.<E> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n          //结果集放入缓存\n          tcm.putObject(cache, key, list); // issue #578 and #116\n        }\n        return list;\n      }\n    }\n    return delegate.<E> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n  }\n\n```\n\n \n\n ————————————————\n原文链接：https://blog.csdn.net/u010890358/article/details/80665753\n\n# **复杂查询环境搭建**\n\n**多对一**\n\n**按照查询嵌套处理**\n\n```java\n<!--    多对一-->\n    <!--思路\n        1、查询所有的信息\n        2、根据pid查出老师的全部信息\n    -->\n\n    <select id=\"getStudent\" resultMap=\"studentTeacher\">\n        select * from people;\n    </select>\n    <resultMap id=\"studentTeacher\" type=\"User\">\n        <result column=\"id\" property=\"id\"/>\n        <result column=\"name\" property=\"name\"/>\n<!--        复杂的属性我们需要单独处理-->\n<!--        对象 association\n            集合 collection\n-->\n        <association property=\"teacher\" column=\"pid\" javaType=\"teacher\" select=\"getTeacher\" />\n    </resultMap>\n\n    <select id=\"getTeacher\" resultType=\"teacher\">\n        select * from  user where id = #{id};\n    </select>\n```\n\n**按照结果嵌套处理** \n\n```xml\n<!--    按照结果嵌套处理-->\n    <select id=\"getStudent2\" resultMap=\"studentTeacher2\">\n        SELECT p.id sid,p.`name` sname,u.`name` tname FROM people p ,`user` u WHERE p.pid = u.id;\n    </select>\n    <resultMap id=\"studentTeacher2\" type=\"user\">\n        <result property=\"id\" column=\"sid\"/>\n        <result property=\"name\" column=\"sname\"/>\n        <association property=\"teacher\" javaType=\"teacher\">\n            <result property=\"name\" column=\"tname\"/>\n        </association>\n    </resultMap>\n```\n\n## **一对多**\n\n第一种**、按照结果嵌套查询**\n\n```xml\n <select id=\"getStudents\" resultMap=\"getTeacherStudent\">\n        SELECT p.id sid,p.name sname,u.`name` tname,u.id tid from people p,`user` u where p.pid = u.id and u.id =#{tid}\n    </select>\n    <resultMap id=\"getTeacherStudent\" type=\"Teacher\">\n        <result property=\"id\" column=\"tid\"/>\n        <result property=\"name\" column=\"tname\"/>\n<!--        集合中的泛型信息，我们用oftype使用-->\n        <collection property=\"students\" ofType=\"user\">\n            <result property=\"id\" column=\"sid\"/>\n            <result property=\"name\" column=\"sname\"/>\n        </collection>\n    </resultMap>\n    \n    结果：\n    Teacher(id=1, name=小刘, students=[User(name=小刘, id=1, address=null, age=null, teacher=null, pid=null), \n    User(name=大刘, id=2, address=null, age=null, teacher=null, pid=null)]\n```\n\n第二种、**按照查询嵌套处理**\n\n```xml\n<select id=\"getStudents2\" resultMap=\"getTeacherStudent2\">\n    select * from user where id = #{tid}\n</select>\n<resultMap id=\"getTeacherStudent2\" type=\"teacher\">\n    <collection property=\"students\" javaType=\"ArrayList\" ofType=\"user\" select=\"getStudentByTeacherId\" column=\"id\" />\n</resultMap>\n<select id=\"getStudentByTeacherId\" resultType=\"user\">\n    select * from people where pid = #{tid}\n</select>\n\n结果:\n    Teacher(id=null, name=小刘, students=[User(name=小刘, id=1, address=光明大道, age=12, teacher=null, pid=1), \n    User(name=大刘, id=2, address=光明大道, age=13, teacher=null, pid=1), \n    User(name=xiaoliu, id=3, address=光明大道, age=31, teacher=null, pid=1)]\n```\n\n**小结：**\n\n关联：association 【多对一】\n\n集合：collection    【一对多】\n\njavaType & ofType\n\njavaType 用来指定实体类属性的类型\n\nofType 用来指定映射到**list**或者集合中的**entity，泛型中的约束类**\n\n**![截图4](截图4.png)**\n\n**注意点：保证sql语句的可读性，尽量保证通俗易懂**\n\n**注意一对多和多对一，属性和字段名的问题**\n\n**如果问题不好排查，可以使用日志**\n\n**面试高频：**\n\n**Mysql引擎**\n\n**InnoDB底层原理**\n\n**索引**\n\n**索引优化！**\n\n\n\n# 动态SQL\n\n什么是动态sql，根据不同的条件生成不同的sql语句。\n\nMyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。\n\n- if\n- choose (when, otherwise)\n- trim (where, set)\n- foreach\n\n## IF\n\n```xml\n<select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\">\n    select * from t_blog where 1=1\n        <if test=\"tittle !=null\">\n            and tittle=#{tittle}\n        </if>\n        <if test=\"description!=null\">\n            and description=#{description}\n        </if>\n</select>\n```', 0, '2022-09-13 23:35:55', '2022-10-21 20:01:00', 0, 124, 5, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/13/4674a8e5ed2443d1880223bbf1c6c689.png', 7);
INSERT INTO `t_blog` VALUES (238, 'mybatis04', 'mybatis笔记', '## trim、where、 set\n\n**where**元素只会在至少有一个子元素的条件返回 SQL子句的情况下才去插入\"WHERE\"子句。而且,若语句的开头为“AND\"或\"OR”， where 元素也会将它们去除。\n\n如果 *where* 元素与你期望的不太一样，你也可以通过自定义 trim 元素来定制 *where* 元素的功能。比如，和 *where* 元素等价的自定义 trim 元素为：\n\n```xml\n<trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \">\n  ...\n</trim>\n```\n\n```java\n记得在工具类中开启自动提交事务\nreturn sqlSessionFactory.openSession(true);\n```\n\n```java\n<update id=\"updateBlog\" parameterType=\"map\">\n    update t_blog\n    <set>\n        <if test=\"tittle!=null\">\n            tittle=#{tittle},\n        </if>\n        <if test=\"description!=null\">\n            description{description}\n        </if>\n    </set>\n        where id =#{id}\n</update>\n```\n\n\n\n\n\n## choose、when、otherwise\n\n```xml\n<select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\">\n    select * from t_blog\n    <where>\n        <choose>\n            <when test=\"tittle!=null\">\n                tittle = #{tittle}\n            </when>\n            <when test=\"description!=null\">\n                and description=#{description}\n            </when>\n            <otherwise>\n                and created_time=#{createdTime}\n            </otherwise>\n        </choose>\n    </where>\n</select>\n```\n\n满足一个条件就返回\n\n### foreach\n\n官方实例\n\n```java\n<select id=\"selectPostIn\" resultType=\"domain.blog.Post\">\n  SELECT *\n  FROM POST P\n  WHERE ID in\n  <foreach item=\"item\" index=\"index\" collection=\"list\"\n      open=\"(\" separator=\",\" close=\")\">\n        #{item}\n  </foreach>\n</select>\n```\n\n案例\n\n```xml\n<select id=\"findByFor\" parameterType=\"map\" resultType=\"blog\">\n        select * from t_blog\n        <where>\n        <foreach collection=\"ids\" item=\"item\" open=\" (\" close=\")\" separator=\"or\">\n           id =  #{item}\n        </foreach>\n        </where>\n    </select>\n```\n\n\n\n# sql片段\n\n将需要公共的sql片段提取出来复用\n\n```xml\n<select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\">\n    select * from t_blog\n    <where>\n        <include refid=\"if-tittle-exist\"></include>\n    </where>\n</select>\n<sql id=\"if-tittle-exist\">\n    <if test=\"tittle !=null\">\n        and tittle=#{tittle}\n    </if>\n    <if test=\"description!=null\">\n        and description=#{description}\n    </if>\n</sql>\n```\n\n注意事项：\n\n最好基于单表定义SQL片段\n\n不要存在where标签\n\n## 总结：\n\n动态sql就是在拼接语句，按照sql的语法拼接就不会有错\n\n# 缓存\n\n存入内存中的临时数据\n\n使用缓存，减少数据库之间的交互，减少系统开销，提高系统效率\n\n## mybatis缓存\n\n默认情况下是开启**一级缓存的**\n\n二级缓存需要手动开启和配置，它是基于namespace级别的缓存（一个接口）\n\nmybatis中也有Cache接口\n\n可用的清除策略有：\n\n- `LRU` – 最近最少使用：移除最长时间不被使用的对象。\n- `FIFO` – 先进先出：按对象进入缓存的顺序来移除它们。\n- `SOFT` – 软引用：基于垃圾回收器状态和软引用规则移除对象。\n- `WEAK` – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。\n\n缓存失效的情况：\n\n1、增删改的情况，\n\n2、查询的参数不一样\n\n3、查询不通的mapper.xml\n\n4、手动删除缓存\n\n### 二级缓存\n\n默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：\n\n```\n<cache/>\n```\n\n在此之前需要开启缓存\n\n### 缓存原理\n\n![image20220916170248156.png](http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/16/1ff53ad3f1e64a44a63ecf1b7b26bdca.png)\n\n## 自定义缓存\n\nehcache\n\n```xml\n<dependency>\n  <groupId>org.mybatis.caches</groupId>\n  <artifactId>mybatis-ehcache</artifactId>\n  <version>1.2.2</version>\n</dependency>\n```\n\nxml\n\n```xml\n    <cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/>\n```\n\nehcache.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"\n         updateCheck=\"true\" monitoring=\"autodetect\"\n         dynamicConfig=\"true\">\n\n\n    <defaultCache\n            maxElementsInMemory=\"1\"\n            eternal=\"false\"\n            overflowToDisk=\"false\"\n            timeToIdleSeconds=\"1800\"\n            timeToLiveSeconds=\"1800\">\n    </defaultCache>\n\n    <cache name=\"data-cache\"\n           maxElementsInMemory=\"500\"\n           overflowToDisk=\"false\"\n           eternal=\"true\"\n           timeToIdleSeconds=\"18000\"\n           timeToLiveSeconds=\"18000\"\n           memoryStoreEvictionPolicy=\"LRU\"\n           transactionalMode=\"off\" />\n    <!--\n    diskStore：指定数据在磁盘中的存储位置。\n defaultCache：当借助CacheManager.add(\"demoCache\")创建Cache时，EhCache便会采用<defalutCache/>指定的的管理策略\n以下属性是必须的：\n maxElementsInMemory - 在内存中缓存的element的最大数目\n maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大\n eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断\n overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上\n以下属性是可选的：\n timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大\n timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大\n diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.\n diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。\n diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作\n memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出）。\n    -->\n</ehcache>\n```', 0, '2022-09-16 22:40:37', '2022-10-21 20:01:00', 0, 124, 4, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/16/1ff53ad3f1e64a44a63ecf1b7b26bdca.png', 7);
INSERT INTO `t_blog` VALUES (239, 'spring02', 'spring学习笔记', '**基于xml方式注入其他属性**\n\n1、字面量\n\n- null值\n\n```xml\n<bean id=\"user\" class=\"com.xiaoliu.entity.User\" >\n    <property name=\"name\">\n        <null/>\n    </property>\n</bean>\n```\n\n- 其他属性\n\n```xml\n<!--    属性转化为特色符号\n        1、把<>进行转义\n        2、把特殊符号内容写到CDATA里\n-->\n    <bean id=\"user\" class=\"com.xiaoliu.entity.User\" >\n        <property name=\"name\">\n            <value>\n                <![CDATA[\n                $XIAOLIU\n                ]]>\n            </value>\n        </property>\n    </bean>\n```\n\n注入属性-外部bean\n\n- 创建service层\n\n**userDao**\n\n```java\npublic interface UserDao {\n    void Update();\n\n}\n```\n\n**UserDaoImpl**\n\n```java\npublic class UserDaoImpl implements UserDao{\n\n    @Override\n    public void Update() {\n        System.out.println(\"进入uodate...\");\n    }\n}\n\n```\n\n**service**\n\n```java\npublic interface Service {\n    void Update();\n\n}\n\n```\n\n**serviceImpl**\n\n```java\npublic class ServiceImpl implements Service{\n    private UserDao userDao;\n\n    public void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n\n\n    @Override\n    public void Update() {\n        userDao.Update();\n    }\n}\n\n```\n\n**bean2.xml配置文件中**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n\n<!--    创建service和dao的对象创建-->\n    <bean id=\"service\" class=\"com.xiaoliu.service.ServiceImpl\">\n<!--        注入userDao的对象\n            ref属性：创建bean中对应的id的值\n    -->\n        <property name=\"userDao\" ref=\"userDao\"></property>\n    </bean>\n    <bean id=\"userDao\" class=\"com.xiaoliu.dao.UserDaoImpl\"></bean>\n</beans>\n```\n\n在spring配置文件中进行配置\n\n注入属性-内部bean和级联赋值 \n\n- 一对多的关系\n\n1、 创建一对多的关系实体，部门对员工\n\n```java\n部门\npublic class Emp {\n    private String name;\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n员工\npublic class Dept {\n    private String ename;\n    private String gender;\n    private Dept dept;\n\n    public void setEname(String ename) {\n        this.ename = ename;\n    }\n\n    public void setGender(String gender) {\n        this.gender = gender;\n    }\n\n    public void setDept(Dept dept) {\n        this.dept = dept;\n    }\n}\n```\n\n2、在spring配置文件中配置\n\n```xml\n<!--    内部bean-->\n    <bean id=\"dept\" class=\"com.xiaoliu.entity.Dept\">\n<!--        设置两个属性-->\n        <property name=\"ename\" value=\"xiaoliu\"></property>\n        <property name=\"gender\" value=\"nan\"></property>\n<!--        d对象类型的属性-->\n        <property name=\"emp\">\n            <bean id=\"emp\" class=\"com.xiaoliu.entity.Emp\">\n                <property name=\"name\" value=\"安保部\"></property>\n            </bean>\n        </property>\n    </bean>\n```\n\n3、测试\n\n```java\n@Test\n    public void test4(){\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"spring/bean3.xml\");\n        Dept dept = context.getBean(\"dept\", Dept.class);\n        dept.toString();\n\n    }\n```\n\n4、注入属性-级联赋值\n\n1、与注入外部bean一致\n\n#### 注入集合类型属性\n\n1、注入数组类型的属性,2、注入List集合属性,3、注入map集合类型属性\n\n 创建实体\n\n```java\npublic class Stu {\n    private String[] course;\n    private List<String> list;\n    private Map<String,String> maps;\n    private Set<String> sets;\n\n    public void setSets(Set<String> sets) {\n        this.sets = sets;\n    }\n\n    public void setList(List<String> list) {\n        this.list = list;\n    }\n\n    public void setMaps(Map<String, String> maps) {\n        this.maps = maps;\n    }\n\n    public void setCourse(String[] course) {\n        this.course = course;\n    }\n}\n\n```\n\nspring配置文件中配置\n\n```xml\n        <bean id=\"stu\" class=\"com.xiaoliu.entity.Stu\">\n<!--                数组类型的注入-->\n                <property name=\"course\">\n                        <array>\n                                <value>daliu</value>\n                                <value>xiaoliu</value>\n                                <value>java</value>\n                                <value>array</value>\n                        </array>\n                </property>\n<!--                集合类型的注入-->\n            <property name=\"list\">\n                <list>\n                    <value>xiaoliu</value>\n                    <value>daliuliu</value>\n                </list>\n            </property>\n<!--            map类型注入-->\n            <property name=\"maps\">\n                <map>\n                    <entry key=\"we\" value=\"value\"></entry>\n                    <entry key=\"we2\" value=\"value2\"></entry>\n                </map>\n            </property>\n<!--            set集合-->\n            <property name=\"sets\">\n                <set>\n                    <value>we</value>\n                    <value>we</value>\n                    <value>we</value>\n                </set>\n            </property>\n        </bean>\n```\n\n#### 注入集合类型为对象属性\n\n实体\n\n```java\npublic class Course {\n    private String cname;\n\n    @Override\n    public String toString() {\n        return \"Course{\" +\n                \"cname=\'\" + cname + \'\\\'\' +\n                \'}\';\n    }\n\n    public void setCname(String cname) {\n        this.cname = cname;\n    }\n}\n\n学生\n        private List<Course> courses;\n```\n\n配置文件\n\n```xml\n<!--            注入list对象集合-->\n            <property name=\"courses\">\n                <list>\n                    <ref bean=\"course1\"></ref>\n                    <ref bean=\"course2\"></ref>\n                </list>\n            </property>\n        </bean>\n<!--创建多个bean对象-->\n    <bean id=\"course1\" class=\"com.xiaoliu.entity.Course\">\n        <property name=\"cname\" value=\"JAVA课程\"></property>\n    </bean>\n    <bean id=\"course2\" class=\"com.xiaoliu.entity.Course\">\n        <property name=\"cname\" value=\"C课程\"></property>\n    </bean>\n```\n\n 把集合注入部分提前出来\n\n1、在spring配置文件中引入名称空间（idea会自动注入）\n\n2、实体\n\n```java\npublic class Book {\n    private List<String> name;\n\n    @Override\n    public String toString() {\n        return \"Book{\" +\n                \"name=\" + name +\n                \'}\';\n    }\n\n    public void setName(List<String> name) {\n        this.name = name;\n    }\n}\n```\n\n3、使用util标签完成list集合提取出来\n\n4、配置文件中\n\n```xml\n \n<!--    提起list集合类型属性注入-->\n    <util:list id=\"bookList\">\n        <value>we</value>\n        <value>qwerqwer</value>\n        <value>qwer</value>\n    </util:list>\n\n    <bean id=\"book\" class=\"com.xiaoliu.entity.Book\">\n        <property name=\"name\" ref=\"bookList\"></property>\n    </bean>\n```\n\n## FactoryBean\n\n1、spring有两种类型的bean、一种普通的bean，另外一种工厂bean\n\n2、普通bean\n\n```xml\n   <bean id=\"book\" class=\"com.xiaoliu.entity.Book\">\n        <property name=\"name\" ref=\"bookList\"></property>\n    </bean>\n```\n\n', 0, '2022-09-20 22:17:12', '2022-10-21 20:01:00', 0, 123, 3, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/09/b4ea827ecfbe4bcfbc3babbd6a256cc3.png', 7);
INSERT INTO `t_blog` VALUES (240, 'Spring学习笔记', 'Spring', '3、工厂bean：在配置文件中定义bean类型可以和返回类型不一样\n\n第一步，创建类：让这个类作为工厂bean，实现接口FactoryBean\n\n第二步，实现接口方法\n\n```java\npublic class FCBean implements FactoryBean<Course> {\n    @Override\n    public Course getObject() throws Exception {\n        Course course = new Course();\n        course.setCname(\"we\");\n        return course;\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return null;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return FactoryBean.super.isSingleton();\n    }\n}\n```\n\n配置文件\n\n```xml\n	    <bean id=\"myBean\" class=\"com.xiaoliu.entity.FCBean\">\n    </bean>\n```\n\n### Bean的作用域\n\n1、在spring中，设置创建bean实例是单实例还是多实例\n\n2、在spring中，在默认情况下，bean是一个单实例对象\n\n3、设置单实例或多实例\n\n（1）配置文件中bean标签有属性（scope）用于设置单实例还是多实例\n\n（2）scope属性\n\n- 默认值singleton，表示单例\n- prototype，表示是多实例对象\n\n（3）singleton和prototype区别\n\n当scope为singleton时，加载spring配置文件时就会创建单实例对象\n\n当scope为prototype时，在调用getBean方法时，创建多实例对象\n\n### Bean的生命周期\n\n1、通过构造器的创建bean实例（无参构造器）\n\n2、为bean的属性设置值和对其他bean引用（调用set方法）\n\n3、调用bean的初始化方法（需要相应的配置）\n\n4、bean可以使用\n\n5、当容器关闭的时，调用bean的销毁方法（需要进行配置销毁方法）\n\n创建实体\n\n```java\n\npublic class InitBean {\n    private String name;\n\n    public InitBean() {\n        System.out.println(\"第一步，通过无参构造器获取对象\");\n    }\n\n    public void setName(String name) {\n        this.name = name;\n        System.out.println(\"第二步，通过set方法获取属性值\");\n    }\n\n    public void InitMethod(){\n        System.out.println(\"第三步，初始化bean\");\n    }\n\n    public void DestroyMethod(){\n        System.out.println(\"第五步，销毁bean\");\n    }\n}\n\n```\n\n配置文件\n\n```xml\n    <bean id=\"initBean\" class=\"com.xiaoliu.entity.InitBean\" init-method=\"InitMethod\" destroy-method=\"DestroyMethod\">\n        <property name=\"name\" value=\"shuxing\"></property>\n    </bean>\n```\n\n测试类\n\n```java\n    @Test\n    public void test4(){\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"spring/bean4.xml\");\n        InitBean stu = context.getBean(\"initBean\", InitBean.class);\n        System.out.println(\"第四步，拿到属性\"+stu);\n\n//        手动让bean销毁\n        context.close();\n    }\n```\n\nbean的后置处理器，一共有七步\n\n1、通过构造器的创建bean实例（无参构造器）\n\n2、为bean的属性设置值和对其他bean引用（调用set方法）\n\n**3、把我们的实例传递给bean的前置处理器的方法（postProcessBeforeInitialization）**\n\n4、调用bean的初始化方法（需要相应的配置）\n\n**5、把我们的实例传递给bean的后置处理器的方法（postProcessAfterInitialization）**\n\n6、bean可以使用\n\n7、当容器关闭的时，调用bean的销毁方法（需要进行配置销毁方法）\n\n**演示添加后置处理器效果**\n\n1、创建类，实现接口BeanPostProcessor，创建后置处理器\n\n```java\npublic class MyBeanPost implements BeanPostProcessor {\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        System.out.println(\"初始化bean之前\");\n        return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName);\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        System.out.println(\"初始化bean之后\");\n        return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);\n    }\n}\n\n```\n\n2、配置文件\n\n```xml\n<!--    配置后置处理器-->\n    <bean id=\"myBeanPost\" class=\"com.xiaoliu.entity.MyBeanPost\">\n\n    </bean>\n```\n\n测试结果一共七步\n\n```\n\n第一步，通过无参构造器获取对象\n第二步，通过set方法获取属性值\n初始化bean之前\n第三步，初始化bean\n初始化bean之后\n第四步，拿到属性com.xiaoliu.entity.InitBean@10a035a0\n第五步，销毁bean\n```\n\n\n\n**-----------------------------------------2022年9月22日 21:08:24---------------------------------------------------**\n\n\n\n### 基于注解方式\n\n#### 1、bean管理操作创建对象的注解\n\n**1、@Component**\n\n**2、@Controller**\n\n**3、@Service**\n\n**4、@Repository**\n\n上面的4个注解功能是一样的，都可以用来创建bean实例\n\n#### 2、实现对象的创建\n\n（1）导包\n\n```xml\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.3.22</version>\n        </dependency>\n```\n\n（2）开启组件扫描\n\n```xml\n<!--    开启组件扫描-->\n    <context:component-scan base-package=\"com.xiaoliu\"></context:component-scan>\n```\n\n（3）使用注解，在类上面\n\n```java\n//在注解中value值可以省略不写，\n//    默认值是类名称，首字母小写\n@Component(value = \"Service\")\npublic class Service {\n    public void test1(){\n        System.out.println(\"注解测试\");\n    }\n}\n\n```\n\n（4）开启组件扫描的配置\n\n```xml\n<!--    实例1\n        use-default-filters=\"false\"\n        自定义扫描的配置\n        include\n        下面的是扫描Controller\n-->\n    <context:component-scan base-package=\"com.xiaoliu\" use-default-filters=\"false\">\n        <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n\n    </context:component-scan>\n<!--    实例2\n        下面的配置是扫描所有的内容\n        exclude\n        不包含Controller\n-->\n    <context:component-scan base-package=\"com.xiaoliu\">\n        <context:exclude-filter type=\"annotation\"\n                                expression=\"org.springframework.stereotype.Controller\"/>\n\n    </context:component-scan>\n```\n\n#### 3、实现属性注入\n\n**（1）@Autowired**\n\n是按照byType注入属性，默认情况下它要求依赖对象必须存在\n\n**（2）@Qualifier**\n\n根据属性名称进行注入，和autowired一起使用\n\n**（3）@Resource**\n\n是按照byName注入属性，是在java-Annotation包下的，但spring支持该注解\n\n但也可以根据类型和名称注入\n\n**（4）@value**\n\n注入普通类型属性\n\n可注入外部属性文件\n\n```java\n注解\n    @Value(\"${username}\")\n    private String name;\n```\n\n配置文件\n\n```xml\n    <bean id=\"configProperties\" class=\"org.springframework.beans.factory.config.PropertiesFactoryBean\">\n        <property name=\"locations\">\n            <list>\n                <value>classpath:config.properties</value>\n            </list>\n        </property>\n    </bean>\n\n    <bean id=\"we\" class=\"org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer\">\n        <property name=\"properties\" ref=\"configProperties\"></property>\n    </bean>\n```\n\n测试\n\n```java\n    @Test\n    public void test2(){\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"spring/bean.xml\");\n        UserController bean = context.getBean(\"userController\", UserController.class);\n        bean.testt();\n```\n\n#### 4、完全注解开发\n\n创建配置类，替代xml配置文件\n\n```java\n    @Test\n    public void test2(){\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);\n        UserController bean = context.getBean(\"userController\", UserController.class);\n        bean.testt();\n    }\n```\n\n# AOP\n\n## 什么是AOP？\n\n面向切面编程（Aspect Oriented Program）\n\n通过[预编译](https://baike.baidu.com/item/预编译/3191547?fromModule=lemma_inlink)方式和运行期间动态代理实现程序功能的统一维护的一种技术。\n\n利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的[耦合度](https://baike.baidu.com/item/耦合度/2603938?fromModule=lemma_inlink)降低，提高程序的可重用性，同时提高了开发的效率。\n\n**简单概括就是不修改源代码，向其添加功能，也可以根据去掉添加的功能**\n\n## 底层原理\n\n1、AOP底层使用了动态代理\n\n（1）有两种清情况动态代理\n\n**第一种，有接口的情况，使用JDK的动态代理**\n\n![20181228090858878](http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/26/79d845fd6ae64a92be9f2b31b0e2234f.png)\n\n\n\n**第二种，没有接口的情况，使用CGLB动态代理**\n\n动态代理需要被代理类实现接口，如果被代理类没有实现接口，那么这么实现动态代理？这时候就需要用到CGLib了。这种代理方式就叫做CGlib代理。\nCglib代理也叫作子类代理，他是通过在内存中构建一个子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，然后加入自己需要的操作。因为使用的是继承的方式，所以不能代理final 类。\n![批注 20220923 005620.png](3)\n\n\n（1）创建被代理类UserService\n\n```java\npublic class UserService {\n	\n\n	public void getName(){\n		System.out.println(\"张三！\");\n	}\n\n}\n```\n\n不能为final\n（2）创建代理工厂类ProxyFactory\n\n```java\npublic class ProxyFactory<T> implements MethodInterceptor {\n\n	private T target;\n	\n	public ProxyFactory(T target) {\n		this.target = target;\n	}\n	\n	// 创建代理对象\n	\n	public Object getProxyInstance() {\n	\n		// 1.cglib工具类\n		Enhancer en = new Enhancer();\n		// 2.设置父类\n		en.setSuperclass(this.target.getClass());\n		// 3.设置回调函数\n		en.setCallback(this);\n	\n		return en.create();\n	}\n\n   //拦截方法\n	@Override\n	public Object intercept(Object obj, Method method, Object[] args,\n			MethodProxy methodProxy) throws Throwable {\n		System.out.println(\"开始事务...\");\n\n		// 执行目标对象的方法\n		Object result = method.invoke(target, args);\n	\n		System.out.println(\"提交事务...\");\n		return result;\n	}\n\n}\n\n```\n\n原文链接：https://blog.csdn.net/qq_34609889/article/details/85317582\n\n\n\n​												**2022年9月23日 17:14:58**\n\n\n\n**JDK动态代理**\n\njava.lang.reflect.Proxy\n\n（1）调用newProxyInstance方法\n\n方法有三个参数\n\n1、类加载器\n\n2、增强方法所在的类，这个类实现的接口，支持多个接口\n\n3、实现这个接口InvocationHandler，创建代理对象，写增强代码\n\n示例\n\n（1）创建接口，定义方法\n\n```java\npublic interface UserDao {\n    public int test(int a, int b);\n}\n\n```\n\n（2）编写实现类，实现方法\n\n```java\npublic class UserDaoImpl implements UserDao {\n    @Override\n    public int test(int a, int b) {\n        return a+ b ;\n    }\n}\n```\n\n（3）使用Proxy类创建接口代理对象\n\n```java\npublic class JDKProxy {\n    public static void main(String[] args) {\n        Class[] interfaces = {\n                UserDao.class\n        };\n        UserDaoImpl userDao = new UserDaoImpl();\n        UserDao o = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao));\n        int test = o.test(1, 2);\n        System.out.println(test);\n    }\n}\n\nclass UserDaoProxy implements InvocationHandler {\n    private Object object;\n\n    public UserDaoProxy(Object object) {\n        this.object = object;\n    }\n\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\n//        方法之前\n        System.out.println(\"方法执行之前...\"+method.getName()+\"传递的参数\"+ Arrays.toString(args));\n\n//       增强方法\n        Object invoke = method.invoke(object, args);\n\n//        方法之后\n        System.out.println(\"方法执行之后...\"+object);\n        return invoke;\n    }\n}\n\n```\n\n## AOP（术语）\n\n**1、连接点**\n\n类里面哪些方法可以被增强，这些方法被称为连接点\n\n**2、切入点**\n\n实际被真正增强的方法，称为切入点\n\n**3、通知（增强）**\n\n（1）实际被增强的部分，被称为通知（增强）\n\n（2）通知有很多类型\n\n- 前置通知\n\n​			方法前\n\n- 后置通知\n\n​			方法后\n\n- 环绕通知\n\n​			方法前后\n\n- 异常通知\n\n​			异常时\n\n- 最终通知\n\n​			最终（类似finally）\n\n**4、切面**\n\n是动作，把通知应用到切入点过程\n\n## AOP操作\n\n1、spring框架一般都是基于AspectJ实现AOP操作\n\n（1）什么是AspectJ?\n\nAspectJ不是spring组成部分，独立AOP，一般都是与spring框架一起实现AOP操作\n\n2、基于AspectJ实现AOP操作\n\n（1）基于xml配置文件方式实现\n\n（2）基于注解方式实现（一般使用）\n\n3、导包\n\n```xml\n<dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aspects</artifactId>\n            <version>5.3.23</version>\n        </dependency>\n```\n\n4、切入点的表达式\n\n（1）切入点表达式的作用：我们对哪个类里的哪个方法进行增强\n\n（2）语法结构：\n\n**Execution([权限修饰符] [返回类型] [类全路径] [方法名称] ([参数列表]))**\n\n```\n实例1：对com.xiaoliu.dao.UserDao类里面的add进行增强\n\nExecution（public void com.xiaoliu.dao.UserDao.add(...)）\n\n\n\n实例2：对com.xiaoliu.dao.UserDao类里面的所有进行增强\n\nExecution（public void com.xiaoliu.dao.UserDao.*(...)）\n\n\n\n实例2：对com.xiaoliu.dao.*包里所有的类、方法进行增强\n\nExecution（public void com.xiaoliu.dao.UserDao.*(...)）\n```\n\n### 基于AspectJ注解\n\n#### 1、创建类，编写方法\n\n```java\npublic class User {\n    public void add(){\n        System.out.println(\"add...\");\n    }\n}\n```\n\n#### 2、创建增强类（编写增强逻辑）\n\n```java\npublic class UserProxy {\n//    前置通知\n    public void before(){\n        System.out.println(\"before...\");\n    }\n}\n```\n\n#### 3、进行通知的配置\n\n（1）在spring配置文件中，开启注解的扫描\n\n```xml\n<!--    开启注解扫描-->\n    <context:component-scan base-package=\"com.xiaoliu\"></context:component-scan>\n```\n\n（2）使用注解创建User和UserPorxy对象\n\n```java\n@Component\npublic class User {\n    public void add(){\n        System.out.println(\"add...\");\n    }\n}\n\n@Component\npublic class UserProxy {\n//    前置通知\n    public void before(){\n        System.out.println(\"before...\");\n    }\n}\n\n```\n\n（3）在增强类上面添加注解@Aspect\n\n```java\n@Component\n@Aspect\npublic class UserProxy {\n//    前置通知\n    public void before(){\n        System.out.println(\"before...\");\n    }\n}\n```\n\n（4）在spring配置文件中，开启生成代理对象\n\n```xml\n<!--    开启aspect生成代理对象、-->\n    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n```\n\n#### 4、配置不同类型的通知\n\n（1）在我们增强类的里面，在作为通知方法的上添加通知类型的注解，使用切入点表达式配置\n\n**@Before表示前置通知**\n\n```java\n@Component\n@Aspect\npublic class UserProxy {\n//    前置通知\n//    before作为前置通知\n    @Before(value = \"execution(public void com.xiaoliu.aop.User.add(..))\")\n    public void before(){\n        System.out.println(\"before...\");\n    }\n\n    //最终通知\n    @After(value = \"execution(public void com.xiaoliu.aop.User.add(..))\")\n    public void after(){\n        System.out.println(\"after...\");\n    }\n    //@Around 环绕通知 @AfterReturning后置通知 @AfterThrowing异常通知 \n}\n```\n\n#### 5、抽取公共切入点表达式\n\n```java\n//    相同切入点抽取\n    @Pointcut(value = \"execution(public void com.xiaoliu.aop.User.add(..))\")\n    public void pointdemo(){\n    }\n\n//    前置通知\n//    before作为前置通知\n    @Before(value = \"pointdemo()\")\n    public void before(){\n        System.out.println(\"before...\");\n    }\n```\n\n#### 6、有多个增强类对同一个方法进行增强，设置增强类优先级\n\n（1）在增强类上添加注解@Order（数字类型值），值越小优先级越高\n\n```java\n@Component\n@Aspect\n@Order(1)\npublic class PersonProxy {\n\n\n    //    相同切入点抽取\n    @Pointcut(value = \"execution(public void com.xiaoliu.aop.User.add(..))\")\n    public void pointDemo(){\n    }\n\n    //    前置通知\n//    before作为前置通知\n    @Before(value = \"pointDemo()\")\n    public void before(){\n        System.out.println(\"Person before...\");\n    }\n}\n```\n\n### 基于AspectJ配置文件\n\n#### 1、创建两个类，增强类和被增强类，创建方法\n\n```java\npublic class Book {\n    public void buy(){\n        System.out.println(\"buy...\");\n    }\n}\n\npublic class BookProxy {\n    public void before(){\n        System.out.println(\"before...\");\n    }\n}\n```\n\n#### 2、在spring配置文件中创建两个对象\n\n```xml\n\n    <bean id=\"book\" class=\"com.xiaoliu.aopXml.Book\"></bean>\n    <bean id=\"bookProxy\" class=\"com.xiaoliu.aopXml.BookProxy\"></bean>\n```\n\n#### 3、在spring中配置切入点 、切面\n\n```xml\n	<!--    配置aop增强-->\n    <aop:config>\n<!--        配置切入点-->\n        <aop:pointcut id=\"p\" expression=\"execution(* com.xiaoliu.aopXml.Book.buy(..))\"/>\n\n<!--        配置切面-->\n        <aop:aspect ref=\"bookProxy\">\n            <aop:before method=\"before\" pointcut-ref=\"p\"></aop:before>\n        </aop:aspect>\n    </aop:config>\n```\n\n#### 4、完全注解开发\n\n```java\n@Configuration\n@ComponentScan(basePackages = {\"com.xiaoliu\"})\n@EnableAspectJAutoProxy(proxyTargetClass = true)\n```\n\n# 事务管理\n\n## 1、声明式事务管理\n\n（1）基于注解方式（使用）\n\n​	在spring配置文件中，配置事务管理器\n\n（2）基于xml配置文件方式\n\n**底层使用到了AOP**\n\n1、在配置文件中配置事务管理器\n\n```xml\n<!--    创建事务管理器-->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n<!--        注入数据源-->\n        <property name=\"dataSource\" ref=\"dataSource\"></property>\n    </bean>\n```\n\n2、开启事务注解\n\n```xml\n<!--    开启事务注解-->\n    <tx:annotation-driven transaction-manager=\"transactionManager\"></tx:annotation-driven>\n```\n\n3、在service类上或者类里面的方法上添加事务注解\n\n```java\n@Service\n@Transactional\npublic class UserServiceImpl implements UserService\n```\n\n（1）如果把注解添加类上，这个类的所有方法都添加事务\n\n### 事务参数\n\n#### （1）传播行为（propagation）\n\n当一个事务方法被另一个事务方法调用时，这个事务方法如何进行\n\n![20170420212829825](20170420212829825.png)\n\n##### 1、PROPAGATION_REQUIRED\n\n如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。\n可以把事务想像成一个胶囊，在这个场景下方法B用的是方法A产生的胶囊（事务）。\n\n![20170420213050220](20170420213050220.bmp)\n\n##### 2、PROPAGATION_SUPPORTS\n\n如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。\n\n```java\n@Transactional(propagation = Propagation.REQUIRED)\npublic void methodA() {\n methodB();\n// do something\n}\n\n// 事务属性为SUPPORTS\n@Transactional(propagation = Propagation.SUPPORTS)\npublic void methodB() {\n    // do something\n}\n\n```\n\n##### 3、PROPAGATION_MANDATORY\n\n如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。\n\n如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。\n\n```java\n@Transactional(propagation = Propagation.REQUIRED)\npublic void methodA() {\n methodB();\n// do something\n}\n\n// 事务属性为MANDATORY\n@Transactional(propagation = Propagation.MANDATORY)\npublic void methodB() {\n    // do something\n}\n```\n\n##### 4、PROPAGATION_REQUIRES_NEW\n\n![a8c23d3cea1f42819eb114eabbb570fa](a8c23d3cea1f42819eb114eabbb570fa.png)\n\n##### 5、PROPAGATION_NOT_SUPPORTED\n\nPROPAGATION_NOT_SUPPORTED 总是非事务地执行，**并挂起任何存在的事务**。使用PROPAGATION_NOT_SUPPORTED,也需要使用JtaTransactionManager作为事务管理器。\n\n![20170420213400079](20170420213400079.png)\n\n##### 6、PROPAGATION_NEVER\n\n总是非事务地执行，如果存在一个活动事务，则抛出异常。\n\n##### 7、PROPAGATION_NESTED\n\n如果一个活动的事务存在，则运行在一个[嵌套](https://so.csdn.net/so/search?q=嵌套&spm=1001.2101.3001.7020)的事务中。 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行。\n这是一个嵌套事务,使用JDBC 3.0驱动时,仅仅支持DataSourceTransactionManager作为事务管理器。\n需要JDBC 驱动的java.sql.Savepoint类。使用PROPAGATION_NESTED，还需要把PlatformTransactionManager的nestedTransactionAllowed属性设为true(属性值默认为false)。\n\n![20170420213432872](20170420213432872.png)\n\n博客原文https://blog.csdn.net/qq_32424381/article/details/123561275\n\n#### （2）隔离级别（ioslation）\n\n隔离性：多事务操作之间不会产生影响， 不考虑隔离性会产生很多问题\n\n有三个读问题：\n\n- 脏读\n\n一个未提交的事务读取到了另一个未提交事务的数据\n\n- 不可重复读\n\n一个未提交的事务读取到另一个提交事务修改数据\n\n- 幻读（虚读）\n\n一个未提交的事务读取到另一个提交事务添加数据\n\n**解决：通过设置隔离级别**\n\n![image-20220923224005825](image-20220923224005825.png)\n\n**注解**\n\nspring默认（可重复读）\n\n```java\n@Service\n@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.READ_COMMITTED)\npublic class UserServiceImpl implements UserService {\n```\n\n#### （3）其他参数\n\n1、timeout（超时时间）\n\n事务在规定时间内提交，如果不提交则进行回滚\n\n默认值是-1，设置时间 秒为单位\n\n2、readOnly（是否只读）\n\n默认值false，表示可以查询，可以增删改\n\n3、rollbackFor（回滚）\n\n设置出现哪些异常进行事务回滚\n\n4、norollbackFor（不回滚）\n\n设置哪些异常不进行回滚\n\n### 基于xml方式\n\n1、spring配置文件中\n\n（1）配置事务管理器\n\n```xml\n    <!-- 1.将mybatis配置环境集成到spring中，交由Spring托管 -->\n    <context:property-placeholder location=\"classpath:jdbc.properties\"/>\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        <property name=\"driverClassName\" value=\"${mysql.driver}\"></property>\n        <property name=\"username\" value=\"${mysql.username}\"/>\n        <property name=\"password\" value=\"${mysql.password}\"/>\n        <property name=\"url\" value=\"${mysql.url}\"/>\n        <property name=\"initialSize\" value=\"${druid.pool.init}\"/>\n        <property name=\"minIdle\" value=\"${druid.pool.minIdle}\"/>\n        <property name=\"maxActive\" value=\"${druid.pool.maxActive}\"/>\n        <property name=\"maxWait\" value=\"${druid.pool.maxWait}\"/>\n    </bean>\n\n    <bean id=\"jdbc\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n        <property name=\"dataSource\" ref=\"dataSource\"></property>\n    </bean>\n\n    <!--    创建事务管理器-->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <!--        注入数据源-->\n        <property name=\"dataSource\" ref=\"dataSource\"></property>\n    </bean>\n```\n\n（2）配置通知\n\n（3）配置切入面\n\n### 完全注解方式\n\n1、创建配置类、替代xml配置文件\n\n```java\n@Configuration\n@ComponentScan(basePackages = {\"com.xiaoliu\"})\n@EnableTransactionManagement\npublic class TXConfig {\n\n//    创建数据库连接池\n    @Bean\n    public DruidDataSource getDruid(){\n        DruidDataSource source = new DruidDataSource();\n        source.setDriverClassName(\"com.mysql.cj.jdbc.Driver\");\n        source.setUrl(\"jdbc:mysql://localhost:3306/jdbc?useUnicode=true;characterEncoding=utf8;serverTimezone=GMT8\");\n        source.setUsername(\"root\");\n        source.setPassword(\"123456\");\n        return source;\n    }\n\n//    创建jdbcTemplate\n    @Bean\n    public JdbcTemplate getJdbcTemplate(DataSource dataSource){\n        JdbcTemplate template = new JdbcTemplate();\n//        注入DataSource\n        template.setDataSource(dataSource);\n        return template;\n    }\n\n//    创建事务管理器\n    @Bean\n    public DataSourceTransactionManager getTransactionManager(DataSource dataSource){\n        DataSourceTransactionManager manager = new DataSourceTransactionManager();\n        manager.setDataSource(dataSource);\n        return manager;\n    }\n}\n\n```\n\n2、测试类\n\n```java\n    @Test\n    public void test2(){\n        AnnotationConfigApplicationContext context =\n                new AnnotationConfigApplicationContext(TestFiled.class);\n        UserDaoImpl dao = context.getBean(\"userDaoImpl\", UserDaoImpl.class);\n        List<User> users = dao.getUserList();\n        for (User user : users) {\n            System.out.println(user.toString());\n        }\n    }\n```\n\n\n\n## Spring事务管理API\n\n（1）提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类\n\n![image-20220923205648431](image-20220923205648431.png)\n\n# 功能\n\n## 整合日志框架\n\n1、导包\n\n```xml\n  <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>1.7.33</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.logging.log4j</groupId>\n            <artifactId>log4j-slf4j-impl</artifactId>\n            <version>2.17.1</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.logging.log4j</groupId>\n            <artifactId>log4j-api</artifactId>\n            <version>2.5</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.logging.log4j</groupId>\n            <artifactId>log4j-core</artifactId>\n            <version>2.5</version>\n        </dependency>\n```\n\n2、创建配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--日志级别以及优先级排序: OFF > FATAL > ERROR > WARN > INFO > DEBUG > TRACE > ALL -->\n<!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出-->\n<!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数-->\n<configuration status=\"DEBUG\" monitorInterval=\"30\">\n    <!--先定义所有的appender-->\n    <appenders>\n        <!--这个输出控制台的配置-->\n        <console name=\"Console\" target=\"SYSTEM_OUT\">\n            <!--输出日志的格式-->\n            <PatternLayout pattern=\"[%d{HH:mm:ss:SSS}] [%p] - %l - %m%n\"/>\n        </console>\n    </appenders>\n        <!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用-->\n        <File name=\"log\" fileName=\"log/test.log\" append=\"false\">\n            <PatternLayout pattern=\"%d{HH:mm:ss.SSS} %-5level %class{36} %L %M - %msg%xEx%n\"/>\n        </File>\n    <!--然后定义logger，只有定义了logger并引入的appender，appender才会生效-->\n    <loggers>\n        <root level=\"info\">\n            <appender-ref ref=\"Console\"/>\n        </root>\n    </loggers>\n</configuration>\n```\n\n## @Nullable注解\n\n​	可以使用方法上面，属性上，参数上。注解下允许为空。\n\n## spring支持函数式编程\n\n```java\npublic void test3(){\n        GenericApplicationContext context = new GenericApplicationContext();\n//        清空内容，注册\n        context.refresh();\n        context.registerBean(\"user1\",User.class,()->new User());\n//        获取spring中注册的对象\n        Object user1 = context.getBean(\"user1\");\n        System.out.println(user1);\n    }\n```\n\n## 整合JUnit单元测试\n\n### JUnit4\n\n1、导包\n\n```xml\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-test</artifactId>\n  <version>5.3.23</version>\n</dependency>\n```\n\n2、创建测试类，使用注解完成\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:bean.xml\")\npublic class SpringTest {\n    @Autowired\n    private UserDao userDao;\n\n    @Test\n    public void test(){\n        List<User> userList = userDao.getUserList();\n        for (User user : userList) {\n            System.out.println(user.toString());\n        }\n    }\n\n}\n```\n\n### JUnit5\n\n1、导入junit5的包\n\n2、创建测试类\n\n```java\n@ExtendWith(SpringExtension.class)\n@ContextConfiguration(\"classpath:bean.xml\")\npublic class JTest5 {\n    @Autowired\n    private UserDao userDao;\n\n    @Test\n    public void test(){\n        List<User> userList = userDao.getUserList();\n    }\n\n}\n```\n\n### 测试改进\n\n```java\n//复合注解\n@SpringJUnitConfig(locations = {\"classpath:bean.xml\"})\npublic class JTest5 {\n    @Autowired\n    private UserDao userDao;\n\n    @Test\n    public void test(){\n        List<User> userList = userDao.getUserList();\n    }\n\n}\n\n```\n\n# SpringWebflux\n\n### 1、介绍\n\n（1）是spring5添加的新模块，用于web开发，功能和springMVC类似， 响应式编程出现的框架\n\n（2）使用传统web框架，比如springMVC ，这些都是基于Servlet容器，Webflux是一种异步非阻塞的框架，异步非阻塞在Servlet3.1之后支持，核心基于Reactor的相关API实现的。\n\n（3）Webflux特点\n\n1、非阻塞式：在有限资源下，提高系统的吞吐量和伸缩性，以Reactor为基础实现响应式编程\n\n2、函数式编程：Webflux使用JAVA8函数式编程方式实现路由请求\n\n（4）比较SpringMVC\n\n![image-20220924214524962](image-20220924214524962.png)\n\n1、两者都能使用注解，都运动在Tomcat容器中，	\n\n2、SpringMVC采用命令式编程，一行行代码执行，而WebFlux完全不一样，采用异步响应式编程\n\n### 2、响应式编程\n\n（1）什么是响应式编程？\n\n响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。	\n\n例如电子表格\n\n（2）Java8及其之前版本中\n\n涉及到设计模式：**观察者模式**，涉及到两个类Observer和Observable\n\n\n\n```java\npublic static void main(String[] args) {\n        Observer observer = new Observer();\n//        添加观察者\n        observer.addObserver((o,arg)->{\n            System.out.println(\"发生了变化...\");\n        });\n        observer.addObserver((o,arg)->{\n            System.out.println(\"被观察者通知，准备改变...\");\n        });\n        observer.setChanged();//知道数据的变化\n        observer.notifyObservers();//通知\n    }\n//倒序遍历通知\n```\n\n#### Reactor实现\n\n（1）响应式编程操作中，满足Reactive规范框架\n\n（2）Reactor有两个核心类，Mono和Flux，这两个类都实现了Publisher接口\n\n提供了丰富的操作符。Flux对象实现发布者，返回n个元素；Mono实现发布者，返回1个或0个元素\n\n（3）Flux和Mono都是数据流的发布者，两者都可以发出三种信号，分别是元素值，错误信号，终止信号，后两者都是终止信号，用于告诉订阅者数据流结束了，错误信号：终止数据流同时把错误信息传递给订阅者\n\n（4）通过代码演示Flux和Mono\n\n导包\n\n```xml\n<dependency>\n            <groupId>io.projectreactor</groupId>\n            <artifactId>reactor-core</artifactId>\n        </dependency>\n```\n\n```java\npublic static void main(String[] args) {\n//        just方法直接声明\n        Flux.just(1, 2, 3, 4);\n        Mono.just(1);\n//        其他方法\n        Integer[] array = {1, 2, 3, 4};\n        Flux.fromArray(array);\n\n\n        List<Integer> list = Arrays.asList(array);\n        Flux.fromIterable(list);\n\n        Stream<Integer> stream = list.stream();\n        Flux.fromStream(stream);\n    }\n```\n\n三种信号的特点：\n\n错误信号和完成信号都是终止信号，两者不能共存。\n\n如果没有发送任何元素值，而是直接发送错误或者完成信号，表示是空数据流\n\n如果没有错误信号，没有完成信号，表示是无限数据流\n\n（5）**有订阅才有发布**\n\n`Flux.just(1, 2, 3, 4).subscribe(System.out::print);`\n\n（6）操作符\n\n对我们数据流一道操作，就称为操作符，比如工厂流水线\n\n一、map元素映射为新元素\n\n![image-20220924234727900](image-20220924234727900.png)	\n\nmap可以对数据进行处理\n\n二、flatMap元素映射为流\n\n![image-20220924234922201](image-20220924234922201.png)\n\n将元素映射成流，之后多个流合并成更大的流在一起返回\n\n### 3、Webflux执行流程和核心API\n\nSpringWebflux基于Reactor，默认Netty容器，Netty是高性能，NIO框架\n\n（1）Netty\n\nBIO（阻塞）\n\n![image-20220925000124772](image-20220925000124772.png) \n\nNIO（非阻塞）\n\n![ ](image-20220925001131463.png)\n\n\n\n**--------------------------------------------------------2022年9月25日 12:52:34----------------------------------------**\n\n（2）SpringWebflux执行过程和SpringMVC相似的\n\n- SpringWebflux核心控制器DispatcherHandler，实现接口WebHandler\n\n（3）SpringWebflux核心控制器DispatcherHandler，负责请求映射\n\n- HandlerMapping：请求查询处理的方法\n\n- HandlerAdapter：真正负责请求的处理\n- HandlerResultHandler：响应结果的处理\n\n（4）SpringWebflux实现函数式编程，两个接口：RouterFunction和HandlerFunction（处理具体的函数）\n\n### 4、 SpringWebflux（基于注解编程模型）\n\n实现方式有两种：注解编程模型、函数式编程模型\n\n注解模型：只需要将相关依赖配置到项目中，SpringBoot自动装配到相关容器，默认情况下使用Netty服务器\n\n第一步、引入webflux相关依赖\n\n```xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-webflux</artifactId>\n            <version>2.7.3</version>\n        </dependency>\n```\n\n\n\n第二步、准备工作\n\n创建对应接口\n\n```java\npublic interface UserService {\n\n    Flux<User> queryByList();\n\n     Mono<User> queryById(Integer id);\n\n    Mono<Void> addUser(Mono<User> user);\n}\n\n```\n\n```\n@Service\npublic class UserServiceImpl implements UserService{\n\n    private final Map<Integer, User> users = new HashMap();\n    public UserServiceImpl(){\n        this.users.put(1, new User(\"xiaoliu\",1,23));\n        this.users.put(2, new User(\"xiaoliu1\",2,23));\n        this.users.put(3, new User(\"xiaoliu2\",3,23));\n        this.users.put(4, new User(\"xiaoliu3\",4,23));\n        this.users.put(5, new User(\"xiaoliu4\",5,23));\n        this.users.put(6, new User(\"xiaoliu5\",6,23));\n    }\n\n\n    @Override\n    public Flux<User> queryByList() {\n        return Flux.fromIterable(this.users.values());\n    }\n\n    @Override\n    public Mono<User> queryById(Integer id) {\n        return Mono.justOrEmpty(this.users.get(id));\n    }\n\n    @Override\n    public Mono<Void> addUser(Mono<User> userMono) {\n\n        return userMono.doOnNext(person->{\n            int i = users.size() + 1;\n                users.put(i,person);\n        }).thenEmpty(Mono.empty());\n    }\n}\n```\n\nservice\n\n```java\n@Service\npublic class UserServiceImpl implements UserService{\n\n    private final Map<Integer, User> users = new HashMap();\n    public UserServiceImpl(){\n        this.users.put(1, new User(\"xiaoliu\",1,23));\n        this.users.put(2, new User(\"xiaoliu1\",2,23));\n        this.users.put(3, new User(\"xiaoliu2\",3,23));\n        this.users.put(4, new User(\"xiaoliu3\",4,23));\n        this.users.put(5, new User(\"xiaoliu4\",5,23));\n        this.users.put(6, new User(\"xiaoliu5\",6,23));\n    }\n\n\n    @Override\n    public Flux<User> queryByList() {\n        return Flux.fromIterable(this.users.values());\n    }\n\n    @Override\n    public Mono<User> queryById(Integer id) {\n        return Mono.justOrEmpty(this.users.get(id));\n    }\n\n    @Override\n    public Mono<Void> addUser(Mono<User> userMono) {\n\n        return userMono.doOnNext(person->{\n            int i = users.size() + 1;\n                users.put(i,person);\n        }).thenEmpty(Mono.empty());\n    }\n}\n\n```\n\ncontroller\n\n```java\n@RestController\n@RequestMapping(\"/user\")\npublic class UserController {\n    @Autowired\n    private UserService userService;\n\n    @GetMapping(\"/get/{id}\")\n    public Mono<User> getId(@PathVariable Integer id){\n        Mono<User> mono = userService.queryById(id);\n        return mono;\n    }\n\n    @GetMapping(\"/query\")\n    public Flux<User> list(){\n        Flux<User> userFlux = userService.queryByList();\n        return userFlux;\n    }\n\n    @PostMapping(\"/add\")\n    public Mono<Void> add(@RequestBody User user){\n        Mono<User> userMono =  Mono.just(user);\n        Mono<Void> voidMono = userService.addUser(userMono);\n        return voidMono;\n    }\n\n}\n```\n\n**SpringBoot实现：**异步非阻塞方式，Webflux、Netty、Reactor\n\n**SpringMVC实现：**同步阻塞方式，基于SpringMVC+Servlet+Tomcat\n\n### 5、 SpringWebflux（基于函数式编程模型）\n\n（1）在使用函数式编程模型操作的时候，需要自己初始化服务器，\n\n（2）基于函数式编程模型，有两个核心接口：RouterFunction（实现路由功能，请求转发给对应的handler）和HandlerFunction（处理请求，生成相应的函数）。核心任务定义这两个函数式接口的实现并且启动需要的服务器。\n\n（3）SpringWebflux请求和响应不再是ServletRequest和ServletResponse,而是\n\n**ServerRequest**和**ServerResponse**\n\n第一步 创建Handler（具体实现方法）\n\n```java\npublic class UserHandler {\n    private final UserService userService;\n    public UserHandler(UserService userService){\n        this.userService = userService;\n    }\n\n    //根据id查询用户\n    public Mono<ServerResponse> getId(ServerRequest request){\n        Integer id = Integer.valueOf(request.pathVariable(\"id\"));\n//        空值处理\n        Mono<ServerResponse> noFound = ServerResponse.notFound().build();\n        Mono<User> userMono = this.userService.queryById(id);\n        //把userMono转换返回\n        //使用Reactor用FlatMap\n        return\n        userMono\n                .flatMap(person -> ServerResponse.ok().contentType(MediaType.APPLICATION_JSON)\n                        .bodyValue(person))\n                        .switchIfEmpty(noFound);\n    }\n        //查询所有\n    public Mono<ServerResponse> getList(ServerRequest request){\n        Flux<User> query = this.userService.queryByList();\n        return ServerResponse.ok()\n                .contentType(MediaType.APPLICATION_JSON)\n                .bodyValue(query);\n    }\n    //添加用户\n    public Mono<ServerResponse> save(ServerRequest request){\n//        得到user对象\n        Mono<User> userMono = request.bodyToMono(User.class);\n        return ServerResponse.ok().build(this.userService.addUser(userMono));\n    }\n}\n```\n\n第三步 初始化服务器，编写Router\n\n```java\npublic class Server {\n//    创建router路由\n    public RouterFunction<ServerResponse> routingFunction(){\n        UserService userService = new UserServiceImpl();\n        UserHandler userHandler = new UserHandler(userService);\n\n        return RouterFunctions.route(\n                        GET(\"/users/{id}\").and(accept(MediaType.APPLICATION_JSON)), userHandler::getId\n                ).andRoute(GET(\"users\").and(accept(MediaType.APPLICATION_JSON)), userHandler::getList)\n                .andRoute(POST(\"add\").and(accept(MediaType.APPLICATION_JSON)), userHandler::save);\n    }\n\n//    创建服务器完成适配\n    public void creatReactorServer(){\n//        路由和handler适配\n        RouterFunction<ServerResponse> route = routingFunction();\n\n        HttpHandler handler = toHttpHandler(route);\n        ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(handler);\n\n//        创建服务器\n        HttpServer httpServer =HttpServer.create();\n        httpServer.handle(adapter).bindNow();\n\n    }\n\n}\n```\n\n第四步 创建服务器完成适配\n', 0, '2022-09-26 15:45:09', '2022-10-21 20:01:00', 0, 123, 4, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/26/79d845fd6ae64a92be9f2b31b0e2234f.png', 7);
INSERT INTO `t_blog` VALUES (241, 'SpringMVC01', '开始学习springmvc~', '# 简介\n\n什么是SpringMVC\n\nSpring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 [Web](https://baike.baidu.com/item/Web/150564?fromModule=lemma_inlink) 应用程序的全功能 MVC 模块。\n\n# SpringMVC特点\n\n- 是spring产品，与IOC容器可以无缝连接\n- 基于原生的Servlet\n- 内部组件化程度高\n- 性能高\n\n# 第一个SpringMVC项目\n\n## 1、导包\n\n```xml\n<!--        springMVC-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>5.3.20</version>\n        </dependency>\n\n<!--        日志-->\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>1.2.11</version>\n        </dependency>\n\n<!--        Servlet-->\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>javax.servlet-api</artifactId>\n            <version>4.0.1</version>\n            <scope>provided</scope>\n        </dependency>\n\n<!--        thymeleaf整合-->\n        <dependency>\n            <groupId>org.thymeleaf</groupId>\n            <artifactId>thymeleaf-spring5</artifactId>\n            <version>3.0.15.RELEASE</version>\n        </dependency>\n```\n\n## 2、web.xml\n\n（1）默认方式\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n\n<!--    配置springmvc的前端控制器，对浏览器发送的请求进行统一处理-->\n    <servlet>\n        <servlet-name>SpringMVC</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>SpringMVC</servlet-name>\n<!--        \n设置spr ingMVC的核心控制器所能处理的请求的请求路径\n/所匹配的请求可以是/1ogin或. htm1或. js或. css方式的请求路径\n但是/不能匹配. jsp请求路径的请求\n-->\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n</web-app>\n```\n\n（2）扩展方式配置\n\n```xml\n<!--    配置springmvc的前端控制器，对浏览器发送的请求进行统一处理-->\n    <servlet>\n        <servlet-name>SpringMVC</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n<!--        配置pringmvc配置文件的位置和名称-->\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:springMVC.xml</param-value>\n        </init-param>\n<!--        将spring dispatcherServlet初始化时间提前到服务器启动时-->\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n```\n\n## 3、springmvc配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n<!--    扫描组件-->\n    <context:component-scan base-package=\"com.xiaoliu\"></context:component-scan>\n<!--    视图解析器-->\n    <!--配置Thymeleaf视图解析器-->\n    <bean id=\"viewResolver\" class=\"org.thymeleaf.spring5.view.ThymeleafViewResolver\">\n        <property name=\"order\" value=\"1\"></property>\n        <property name=\"characterEncoding\" value=\"UTF-8\"></property>\n        <property name=\"templateEngine\">\n            <bean class=\"org.thymeleaf.spring5.SpringTemplateEngine\">\n                <property name=\"templateResolver\">\n                    <bean class=\"org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver\">\n                        <!--视图前缀-->\n                        <property name=\"prefix\" value=\"/WEB-INF/templates/\"></property>\n                        <!--视图后缀-->\n                        <property name=\"suffix\" value=\".html\"></property>\n                        <property name=\"templateMode\" value=\"HTML5\"></property>\n                        <property name=\"characterEncoding\" value=\"UTF-8\"></property>\n                    </bean>\n                </property>\n            </bean>\n        </property>\n    </bean>\n\n<!--    处理静态资源，例如htm1、js、Css、jpg\n若只设置该标签，则只能访问静态资源，其他请求则无法访问\n此时必须设置<mvc: annotation-driven/>解决问题\n-->\n    <mvc:default-servlet-handler/>\n    <!--开启mvc注解驱动-->\n    <mvc:annotation-driven>\n        <mvc:message-converters>\n            <!--处理响应中文内容乱码-->\n            <bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n                <property name=\"defaultCharset\" value=\"UTF-8\" />\n                <property name=\"supportedMediaTypes \" >\n                    <list>\n                    <value>text/htm1</value>\n                    <value>application/json</value>\n                </list>\n            </property>\n        </bean>\n    </mvc:message-converters>\n</mvc:annotation-driven>\n\n        </beans>\n```\n\n**Thymeleaf视图解析器**\n\n```xml\n<!--配置Thymeleaf视图解析器-->\n    <bean id=\"viewResolver\" class=\"org.thymeleaf.spring5.view.ThymeleafViewResolver\">\n        <property name=\"order\" value=\"1\"></property>\n        <property name=\"characterEncoding\" value=\"UTF-8\"></property>\n        <property name=\"templateEngine\">\n            <bean class=\"org.thymeleaf.spring5.SpringTemplateEngine\">\n                <property name=\"templateResolver\">\n                    <bean class=\"org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver\">\n                        <!--视图前缀-->\n                        <property name=\"prefix\" value=\"/WEB-INF/templates/\"></property>\n                        <!--视图后缀-->\n                        <property name=\"suffix\" value=\".html\"></property>\n                        <property name=\"templateMode\" value=\"HTML5\"></property>\n                        <property name=\"characterEncoding\" value=\"UTF-8\"></property>\n                    </bean>\n                </property>\n            </bean>\n        </property>\n    </bean>\n\n```\n\n注解驱动\n\n```xml\n<!--    处理静态资源，例如htm1、js、Css、jpg\n若只设置该标签，则只能访问静态资源，其他请求则无法访问\n此时必须设置<mvc: annotation-driven/>解决问题\n-->\n    <mvc:default-servlet-handler/>\n    <!--开启mvc注解驱动-->\n    <mvc:annotation-driven>\n        <mvc:message-converters>\n            <!--处理响应中文内容乱码-->\n            <bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n                <property name=\"defaultCharset\" value=\"UTF-8\" />\n                <property name=\"supportedMediaTypes \" >\n                    <list>\n                    <value>text/htm1</value>\n                    <value>application/json</value>\n                </list>\n            </property>\n        </bean>\n    </mvc:message-converters>\n</mvc:annotation-driven>\n\n```\n\n## 4、创建前端控制器\n\n```java\n@Controller\npublic class UserController {\n    // \"/\" ->   /WEB-INF/templates/index.html\n    @RequestMapping(\"/\")\npublic String index(){\n    return \"index\";\n}\n\n@RequestMapping(\"/target\")\npublic String toTarget(){\n    return \"target\";\n}\n}\n```\n\n## 5、总结\n\n浏览器发送请求，请求地址若符合请求前端控制器的url-parttern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器的@RequestMapping注解的value值匹配，若匹配成功，该注解标识的控制器方法就是处理请求的方法，处理请求的方法返回一个字符串类型的视图名称，该视图	名称会被视图解析器解析，加上前缀和后缀组成试图的路径，通过Thymeleaf对试图进行渲染，最终转发所定义的页面。\n\n## 6、项目架构\n\n![image-20220926105928607](http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/26/ac67b53639cf4eec8253f96332c8a2f9.png)\n\n打包方式为war包时，才能配置webapp\n\n# @RequestMapping注解\n\n## 1、注解的功能\n\n其作用就是将请求和处理请求的控制器方法关联起来，建立映射关系\n\nSpringMVC接收到指定的请求，就会找到映射关系中对应的控制器方法来处理这个请求\n\n## 2、@RequestMapping注解的位置\n\n在类上：标识一个类，设置映射请求路径的初始信息\n\n在方法上：标识一个方法，设置映射请求路径的具体信息\n\n## 3、value属性\n\n@RequestMapping中的value属性是一个字符串数组，可以存放多个值，即可以有多个请求地址映射 \n\nvalue值必须设置，至少通过请求地址映射\n\n## 4、method属性\n\nmethod属性通过请求的请求方式（get或post）匹配请求映射\n\nmethod属性是一个**RequestMethod**类型的数组，表示该请求映射能匹配多种请求方式的请求 \n\n若请求的value值满足要求，但是metho不满足则报405错误\n\n## 5、派生出的注解\n\n\n1、对于处理指定请求方式的控制器方法，SpringMVC中提供了 @RequestMapping的派生注解\n处理get请求的映射->@GetMapping\n处理post请求的映射-->@PostMapping\n处理put请求的映射-->@PutMapping\n处理delete请求的映射->@DeleteMapping\n2、常用的请求方式有get, post, put, deleter\n但是目前浏览器只支持get和post,若在form表单提交时,为method设置了其他请求方式的字符串(put或\ndelete)，则按照默认的请求方式get处理\n若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter\n\n## 6、params属性\n\n@RequestMapping注解的params属性通过请求的请求参数匹配请求映射\n@RequestMapping注解的params属性是一个字符串类型的数组， 可以通过四种表达式设置请求参数和请求映射\n的匹配关系\nparam\":要求请求映射所匹配的请求必须携带param请求参数\n\"!param\":要求请求映射所匹配的请求必须不能携带param请求参数\n\"param=value\":要求请求映射所匹配的请求必须携带param请求参数且param=value\n\"param!=value\":要求请求映射所匹配的请求必须携带param请求参数但是param!=value\n\n## 7、headers属性\n\n@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射\n@RequestMapping注解的headers属性是-个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映\n射的匹配关系\n\"header\":要求请求映射所匹配的请求必须携带header请求头信息\n\"!header\":要求请求映射所匹配的请求必须不能携带header请求头信息\n\"header-value\":要求请求映射所匹配的请求必须携带header请求头信息且header-value\n\"header!=value\":要求请求映射所匹配的请求必须携带header请求头信息且header!=value\n若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性, 此时页面显示404错\n误，即资源未找到\n\n## 8、SpringMVC支持ant风格的路径(模糊匹配)\n\n? :表示任意的单个字符\n*: 表示任意的0个或多个字符\n\n【* *】:表示任意的一-层或多层目录\n注意:在使用时，只能使用/  ** /xxx的方式\n\n## 9、SpringMVC支持路径中的占位符（重点）\n\n原始方式 :/xxx?id=1\n\nrest方式：/xxx/1\n\nSpringMVC路径中的占位符常用于restful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参\n\n```java\npublic String index(@PathVariable(value = \"id\") Integer id){\n    return \"index\";\n}\n```\n\n# SpringMVC获取请求参数\n\n## 1、通过servletAPI获取\n\n将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象\n\n## 2、通过控制器方法的形参获取请求参数\n\n多请求参数中出现多个同名的请求参数，可以再控制器方法的形参位置设置字符串类型或字符串数组接收此请求参数\n\n```java\n@RequestMapping(value = \"/users\",method = RequestMethod.GET)\npublic String users(String username,String password){\n    System.out.println(username+\";\"+password);\n    return \"target\";\n}\n```\n\n**当要获取的参数名与控制器方法形参名称不一致时，不能获取到**\n\n## 3、@RequestParam\n\n```java\npublic String users(\n       @RequestParam(\"user_name\") String username,\n       @RequestParam(\"pass_word\") String password){\n    System.out.println(username+\";\"+password);\n    return \"target\";\n}\n```\n\n通过映射前端请求的参数给控制器的形参\n\n- **name**\n\n与value一致\n\n- **required**  （布尔类型）\n\n是否必须\n\n- **defaultValue**\n\n默认值，当指定的value值没有传输时，则使用默认值为形参赋值\n\n## 4、@RequestHeader\n\n该注解是将请求头信息和控制器形参构建映射关系\n\n- name\n- defaultValue\n- required\n\n同@RequestParam一样\n\n```java\n    @RequestMapping(value = \"/users\",method = RequestMethod.GET)\n    public String users(\n            @RequestHeader(\"Host\") String host){\n        System.out.println(\"host\"+host);\n        return \"target\";\n    }\n\n```\n\n## 5、@CookieValue\n\n该注解是将cookie信息与控制器形参构建映射关系\n\n- name\n- defaultValue\n- required\n\n同@RequestParam一样\n\n## 6、通过pojo获取请求参数\n\n可以在控制器方法的形参位置设置一个实体类类型的形参， 此时若浏览器传输的请求参数的参数名和实体类中的属性名一致,那么请求参数就会为此属性赋值\n\n# CharacterEncodingFilter请求参数乱码\n\nweb.xml中注册filter\n\n```xml\n <filter>\n        <filter-name>CharacterEncodingFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>UTF-8</param-value>\n        </init-param>\n        <init-param>\n            <param-name>forceResponseEncoding</param-name>\n            <param-value>true</param-value>\n        </init-param>\n    </filter>\n<filter-mapping>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n# 域对象共享数据\n\nSession的钝化和活化\n\n\n\n## 1、使用ServletAPI向request域对象共享数据\n\n```java\n@Reques tMapping(\"/testServletAPI\")\npublic String testServletAPI (HttpServletRequest request) {\n	request.setAttribute(\"testScope\", \"hello,servletAPI\");\n	return \"success\" ;\n}\n\n```\n\n## 2、使用ModelView向request域对象共享数据\n\nModelAndView有Mode1和Vi ew的功能\nModel主要用于向请求域共享数据\nView主要用于设置视图，实现页面跳转\n\n```java\n    @RequestMapping(\"/mav\")\n    public ModelAndView ModelAndView(){\n        ModelAndView mav = new ModelAndView();\n//        处理模型数据，即向请求域request共享数据\n        mav.addObject(\"testReuqestscope\", \"hello,ModelAndView\");\n        mav.setViewName(\"index\");\n        return mav;\n    }\n```\n\n## 3、使用Model向request域共享数据\n\n```java\n@RequestMapping(\"/test\")\npublic String testModel(Model model) {\n    model.addAttribute(\"testReuqestscope\", \"hello,Model\");\n\n    return \"success\";\n}\n```\n\n## 4、使用map向request域对象共享数据\n\n```java\n@RequestMapping(\"/map\")\npublic String testmap(Map<String,Object> map){\n    map.put(\"testReuqestscope\", \"hello,map\");\n    return \"success\";\n}\n```\n\n## 5、使用ModelMap向request域共享数据\n\n```java\n@RequestMapping(\"/modelmap\")\npublic String testmap(ModelMap map){\n    map.addAttribute(\"testReuqestscope\", \"hello,map\");\n    return \"success\";\n}\n```\n\n## 6、Model、map、ModelMap之间的区别\n\nModel、ModelMap、 Map类型的参数其实本质上都是BindingAwareModelMap类型的\n\n```java\npublic interface Model{}\npublic class ModelMap extends LinkedHashMap<String,object> {}\npublic class ExtendedModelMap extends ModelMap implements Mode1 {}\npublic class Bindi ngAwar eModelMap extends ExtendedModelMap {}\n\n```\n\n## 7、向session域共享数据\n\n```java\n@RequestMapping(\"/test\")\npublic String session(HttpSession session) {\n    session.setAttribute(\"testReuqestscope\", \"hello,Model\");\n    return \"success\";\n}\n```\n\n## 8、向application共享数据\n\n```java\n@RequestMapping(\"/application\")\n    public String testmap(HttpSession session){\n        ServletContext context = session.getServletContext();\n        context.setAttribute(\"testReuqestscope\", \"hello,map\");\n        return \"success\";\n    }\n```\n\n# SpringMVC的视图\n\nSpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户\nSpringMVC视图的种类很多，默认有转发视图和重定向视图\n当工程引入jstl的依赖，转发视图会自动转换为JstIView\n若使用的视图技术为Thymeleaf,在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView\n\n## 1、ThymeleafView\n\n当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解\n析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转\n\n![image-20220926190655195](http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/26/bbe7dbd0c23940d7a018bdf4d6eb1ce1.png)\n\n## 2、转发视图\n\nSpringMVC中默认的转发视图是InternalResourceView，SpringMVC中创建转发视图的情况:\n当控制器方法中所设置的视图名称以\"forward:\"为前缀时，创建InternalResourceView视图， 此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀’forward: \"去掉，剩余部分作为最终路径通过转发的方式实现跳转\n\n```java\n@Reques tMapping(\"/testForward\")\npublic String testForwardO {\nreturn \"forward:/testHello\";\n}\n\n```\n\n## 3、重定向视图\n\nSpringMVC中默认的重定向视图是RedirectView I\n当控制器方法中所设置的视图名称以\"redirect:\"为前缀时，创建RedirectView视图， 此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析,而是会将前缀\'redirect: \'去掉，剩余部分作为最终路径通过重定向的方式实现跳转\n例如\"redirect:/\"，\"redirect:/employee\"\n\n```java\n@Reques tMapping(\"/testRedirect\")\npub1ic String testRedirect(){\nreturn \"redirect:/testHe11o\";\n}\n```\n\n## 4、视图控制器view-controller\n\n', 0, '2022-09-26 23:56:47', '2022-10-21 20:01:00', 0, 126, 2, 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/26/bbe7dbd0c23940d7a018bdf4d6eb1ce1.png', 7);

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `pid` int(0) NULL DEFAULT NULL,
  `blog_id` int(0) NULL DEFAULT NULL COMMENT '关联文章id',
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '内容',
  `created_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `create_by` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '创建者',
  `origin_id` int(0) NULL DEFAULT NULL COMMENT '最上级id',
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 99 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_comment
-- ----------------------------
INSERT INTO `t_comment` VALUES (75, NULL, 53, '这是个测试', '2022-08-29 14:32:15', 'xiaoliu', NULL, '1937589397@qq.com');
INSERT INTO `t_comment` VALUES (80, NULL, 57, 'q', '2022-09-01 22:19:09', 'qwerqwer', NULL, '1937589397@qq.com');
INSERT INTO `t_comment` VALUES (85, NULL, 202, 'ss', '2022-09-05 13:55:25', 'darker', NULL, '1332439635@qq.com');
INSERT INTO `t_comment` VALUES (86, 84, 202, '可以可以', '2022-09-05 13:55:52', 'darker', 84, '1332439635@qq.com');
INSERT INTO `t_comment` VALUES (87, 86, 202, 'hhh回复你', '2022-09-05 13:56:38', '大刘哥', 84, 'qwerqwer');
INSERT INTO `t_comment` VALUES (88, 85, 202, '哈哈哈现在正式加入邮箱回复功能！', '2022-09-05 16:48:38', '大刘哥', 85, '1937589397@qq.com');
INSERT INTO `t_comment` VALUES (89, 86, 202, '可以看到我们的回复吗', '2022-09-05 17:59:48', '大刘哥', 84, '1937589397@qq.com');
INSERT INTO `t_comment` VALUES (90, 84, 202, 'wqerqwerqwer', '2022-09-05 18:02:54', '我', 84, '1937589397@qq.com');
INSERT INTO `t_comment` VALUES (91, NULL, 202, '而我却若群翁人情味', '2022-09-05 18:03:30', '大刘哥1', NULL, '1937589397@qq.com');
INSERT INTO `t_comment` VALUES (92, 91, 202, 'hhhhhhhhhh', '2022-09-05 18:03:49', '小刘哥', 91, '1937589397@qq.com');
INSERT INTO `t_comment` VALUES (93, 89, 202, '测试', '2022-09-05 18:09:16', 'darker', 84, '1332439635@qq.com');
INSERT INTO `t_comment` VALUES (94, NULL, 202, '这是一个t', '2022-09-05 18:10:00', 'darker', NULL, '1332439635@qq.com');
INSERT INTO `t_comment` VALUES (95, 94, 202, '测试', '2022-09-05 18:10:13', 'darker', 94, '1332439635@qq.com');
INSERT INTO `t_comment` VALUES (96, 89, 202, '可以看到回复', '2022-09-05 18:12:47', 'darker', 84, '1332439635@qq.com');
INSERT INTO `t_comment` VALUES (97, NULL, 234, '大刘哥来打卡了', '2022-09-18 19:28:19', '大刘哥', NULL, 'nonewe');
INSERT INTO `t_comment` VALUES (98, NULL, 228, 'test', '2022-10-11 17:53:14', 'hh', NULL, 'nhmjkw');

-- ----------------------------
-- Table structure for t_link
-- ----------------------------
DROP TABLE IF EXISTS `t_link`;
CREATE TABLE `t_link`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '博客名称',
  `photo_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '博客图片',
  `site` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '地址',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_link
-- ----------------------------
INSERT INTO `t_link` VALUES (3, '小刘的博客', 'https://s1.ax1x.com/2022/08/31/v4LTl6.jpg', 'http://lhzzz-61.top');
INSERT INTO `t_link` VALUES (4, '博客', 'https://gcore.jsdelivr.net/gh/Nobodyliek/pic/img/202209172317367.jpg', 'http://someliek.top/');

-- ----------------------------
-- Table structure for t_photo
-- ----------------------------
DROP TABLE IF EXISTS `t_photo`;
CREATE TABLE `t_photo`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '照片名',
  `region` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '地点',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '描述',
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '图片url',
  `file_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文件名',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_photo
-- ----------------------------
INSERT INTO `t_photo` VALUES (1, '测试', '2022年8月29日 家里', '这是个测试的图片', 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/08/29/09f91fc766a44c6ab1f8af994b6afcb4.jpg', '48gv20.jpg');
INSERT INTO `t_photo` VALUES (4, 'q', 'qwe', 'we', 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/08/31/4969e0bb1dfb430eb3dee50dca9771da.jpg', NULL);
INSERT INTO `t_photo` VALUES (5, '上线测试', '20229/5 学校', '测试一哈', 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/05/15f50e1230c344c28fb00418adf0392b.jpg', NULL);
INSERT INTO `t_photo` VALUES (6, '测试2', '2022/9/5 寝室', '无描述', 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/05/526e642b3d544a1b9ed6fe675b93d3cd.jpg', NULL);
INSERT INTO `t_photo` VALUES (7, '学校夜景', '2022年9月5日', '学校官微上找的', 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/05/36b2185ae706425e99c5da8a3d7191fe.jpg', NULL);
INSERT INTO `t_photo` VALUES (9, '省博物馆', '2021年5月3号 博物馆前', '出去走走，还是挺好玩的', 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/07/7400a67a3e754740aad83bb09910a6e6.jpg', NULL);
INSERT INTO `t_photo` VALUES (10, '回家前一天的夕阳美景', '2022年7月15日', '明天准备回家了，和朋友一起去喝酒', 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/16/4669415249034eab878ba7a0a8e59c0f.jpg', NULL);
INSERT INTO `t_photo` VALUES (11, '收音机📻', '2022年7月9日', '收音机修好了，去光明顶上接受信号录视频~', 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/16/a2d9a32686474e24ac7bb867e1db34cd.jpg', NULL);
INSERT INTO `t_photo` VALUES (12, '这是疫情封校时吃过最好吃的番茄鸡🍗', '2022年9月7日', '吃了好几大碗满足🥳', 'http://xitong-parent.oss-cn-hangzhou.aliyuncs.com/2022/09/16/bc6dcec2de3b4406970efcfac9e0469f.jpg', NULL);

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `status` int(0) NULL DEFAULT NULL,
  `modified_time` date NULL DEFAULT NULL,
  `created_time` date NULL DEFAULT NULL,
  `role` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES (3, 'admin', '9dd62788279aae057874348d5fcbaa62', 0, '2022-09-05', '2022-09-05', 'admin');

SET FOREIGN_KEY_CHECKS = 1;
